# 하린

# 13. 렌더링 패턴

웹 페이지는 제공하는 기능에 따라 정적일 수도, 동적일 수도 있습니다.

블로그/뉴스 페이지와 같이 이벤트를 발생시키지 않고, 렌더링 후 하이드레이션이 필요하지 않은 정적인 콘텐츠는 서버에서 생성하여 클라이언트에 그대로 전달하는 렌더링 패턴을 주로 사용합니다.

반면에, 버튼, 필터, 검색창과 같은 동적인 콘텐츠는 렌더링 후 이벤트와 연결하기 위해 클라이언트로 자바스크립트 코드를 전송하는 렌더링 패턴을 주로 사용합니다.

이번 장에서는 다양한 렌더링 패턴을 소개하고, 주어진 요구사항에 적합한 패턴을 선택하는 데에 도움을 제공합니다.

## 13.1 렌더링 패턴의 중요성

렌더링 패턴을 선택하는 것은 개발 경험(DX)와 사용자 경험(UX)에 큰 영향을 미칩니다.

뛰어난 사용자 경험을 제공하기 위해서는 [핵심 웹 지표(Core Web Vitals, CWV)](https://web.dev/articles/vitals?hl=ko)와 같은 지표를 기준으로 앱을 최적화해야 합니다.

- TTFB(Time to First Byte)
  클라이언트가 페이지 콘텐츠의 첫 번째 바이트를 받는 데 걸리는 시간
- FCP(First Contentful Point)
  페이지 이동 후 브라우저가 콘텐츠의 첫 부분을 렌더링하는 데 걸리는 시간
- TTI(Time to Interactive)
  페이지 로드 시작부터 사용자 입력에 빠르게 응답할 수 있을 때까지 걸리는 시간
- LCP(Largest Contentful Paint)
  페이지의 주요 콘텐츠를 로드하고 렌더링하는 데 걸리는 시간
- CLS(Cumulative Layout Shift)
  예상치 못한 레이아웃 변경을 방지하기 위한 시각적 안정성 측정
- FID(First Input Delay)
  사용자가 페이지와 상호작용한 시점부터 이벤트 핸들러가 실행될 수 있는 시점까지의 시간

## 13.2 클라이언트 사이드 렌더링(CSR)

리액트의 CSR에서는 대부분의 로직이 클라이언트에서 실행되며, 데이터를 가져오거나 저장하기 위한 API 호출로 서버와 상호작용합니다.

따라서 거의 모든 UI가 클라이언트에서 생성되며 전체 웹 애플리케이션은 처음 요청 시에 모두 로드됩니다.

사용자가 링크를 클릭하여 탐색할 때 페이지 렌더링을 위한 새로운 요청을 서버로 보내지 않습니다. 대신 클라이언트에서 코드가 실행되어 뷰나 데이터를 갈아끼웁니다.

### 프로세스

![CSR](https://github.com/user-attachments/assets/555fde50-f237-4b0a-b42e-4bf2b63f45d1)

1. 브라우저가 서버에 초기 HTML 파일을 요청합니다.
2. 서버는 CSS, javascript 파일에 대한 링크가 있는 빈 HTML을 브라우저로 전송합니다.
3. 브라우저는 리소스를 다운로드 받고, 기본 요소를 렌더링합니다.
4. 브라우저는 javascript 코드를 실행하여 API 요청 등 동적인 콘텐츠를 추가합니다.
5. 버튼 클릭 등의 사용자 상호작용에 따라 필요한 부분만 리렌더링합니다.

### 장점

- **빠른 인터랙션 제공** : 초기 로딩 후, 새로고침 없이 필요한 데이터만 받아와 동적으로 페이지를 업데이트 하기 때문에 뛰어난 사용자 경험을 제공합니다.

### 단점

- **번들 크기 증가** : 페이지의 복잡성이 증가하면 렌더링에 필요한 자바스크립트 코드의 복잡성과 크기도 증가합니다. 이로 인해 번들의 크기가 커지면 FCP, TTI를 증가시킬 수 있습니다.
- **SEO 취약** : API 응답과 같은 일련의 네트워크 요청으로 인해, 크롤러가 색인하기 전에 의미 있는 콘텐츠가 렌더링 되지 않을 수 있어 SEO에 영향을 미칠 수 있습니다.
- **초기 로딩 속도 느림** : 브라우저가 전체 웹페이지를 렌더링하기 전에 모든 필수 JavaScript 파일을 다운로드하고 실행해야 하기 때문에 페이지 로드 시간이 길어지고, 로드되는 동안 빈 페이지나 로딩 화면을 자주 접하게 될 수 있습니다.

---

## 13.3 서버 사이드 렌더링(SSR)

사용자 요청에 대한 응답으로 렌더링 할 페이지 콘텐츠의 전체 HTML을 서버에서 생성하여 클라이언트로 전송합니다.

SSR은 서버 렌더링 후 클라이언트 사이드에서 UI 컴포넌트를 재생성하는 하이드레이션 과정이 포함됩니다.

### 프로세스

![SSR](https://github.com/user-attachments/assets/ba8a5693-5288-4719-b860-2f667f31c406)

1. 브라우저가 서버에 페이지를 요청합니다.
2. 서버는 해당 페이지에서 필요한 데이터를 페칭하고, HTML을 생성하여 브라우저에 전송합니다.
3. Pre-rendering : 브라우저는 서버로부터 받은 HTML을 받아서 화면에 렌더링합니다.
   이때는 js 코드를 실행하지 않습니다.
4. Hydration : 브라우저는 CSS, js 파일을 다운로드하고, 클라이언트 측에서 상호작용이 가능하도록 페이지를 완성시킵니다.
   이를 **Hydration** 과정이라고 합니다. 자바스크립트 코드들이 이전에 보내진 HTML DOM 요소 위에서 한번 더 렌더링 하면서 필요한 이벤트 핸들러를 설정하는 과정을 포함합니다.

### 장점

- **빨라진 로딩 시간** : 서버에서 HTML을 만들어서 보내주기 때문에 js가 다운로드 되기 전까지 기다리지 않고, 빈화면을 보지 않아도 되어 FCP, LCP를 개선할 수 있습니다.
- **SEO 개선** : 렌더링된 HTML을 웹 크롤러가 색인하여 SEO를 개선할 수 있습니다.

### 단점 및 한계

- **지연된 상호작용** : js 모듈을 다운로드하기 전까지 hydration은 진행되지 않으며, 정적인 웹사이트로 사용자가 상호작용할 수 없습니다.
  여전히 js 번들을 다운로드 받는 과정은 필수적입니다.
- **서버 부하 증가** : 서버에서 렌더링하게 되어 서버의 작업 부하가 증가할 수 있습니다.
- **캐싱 불가** : 서버에서 요청이 올 때마다 HTML을 생성하기 때문에 컨텐츠 캐시가 되지 않습니다.

---

## 13.4 정적 사이트 생성(SSG)

빌드 시점에 HTML을 미리 생성하여 다음 빌드 때 까지 변경되지 않습니다.

데이터가 자주 변경되지 않고, 항상 동일한 데이터를 표시하는 페이지(회사 소개, FAQ, 블로그 등)에 가장 적합합니다.

SSG에서는 정적 파일을 CDN(Content Delivery Network)의 엣지 서버에 저장하여 사용자가 페이지를 요청할 때 가장 가까운 엣지 서버에서 캐시된 파일을 반환하여 응답 시간을 최소화하게 됩니다.

### 프로세스

1. 빌드 시에 모든 가능한 요청에 대해 미리 HTML을 생성합니다.
2. 브라우저가 페이지를 요청하면, 서버는 미리 생성해 둔 HTML을 전송합니다.(엣지 캐싱)
3. 브라우저는 서버로부터 받은 HTML을 렌더링합니다.
4. 추가 페이지 요청시, 미리 생성해 둔 해당 페이지의 HTML을 전송합니다.
5. 필요에 따라 클라이언트에서 데이터를 fetching하여 보여줄 수도 있습니다.

### 장점

- **빠른 로딩 속도** : 모든 페이지가 빌드 시에 미리 생성되므로, 사용자가 페이지 요청시 빠른 로딩 속도로 페이지를 제공합니다.
- **서버 부하 감소** : 미리 생성된 HTML만 제공하므로, 서버 부하가 적습니다.

### 단점

- **데이터 변경에 불편** : 데이터 변경점이 생기면, 전체 페이지를 다시 빌드해야 합니다.

---

## 13.5 점진적 정적 생성(ISR)

SSG와 SSR을 결합한 방식으로, 특정 페이지만 미리 렌더링하고 동적인 페이지는 on-demand 방식으로 렌더링합니다.

특정 시간 간격마다 또는 특정 이벤트 발생시 캐시를 자동으로 무효화하고 페이지를 다시 생성할 수 있습니다.

### 프로세스

1. 빌드 시점에 웹 페이지를 정적으로 생성합니다. `Next.js`에서는 `getStaticProps`에 `revalidate` 옵션을 이용하여 페이지를 언제 다시 생성할지 설정할 수 있습니다.
2. 브라우저가 페이지를 요청하면 미리 생성된 HTML을 전송합니다. (캐싱)
3. 브라우저는 서버로부터 받은 HTML을 렌더링합니다.
4. revalidate 옵션에 설정된 시간이 경과되면, 해당 페이지를 서버에서 재생성합니다. 페이지 재검증이 완료될 때까지 사용자는 캐시된 이전 페이지를 보게됩니다. (Stale-While-Revalidate 전략)

   <aside>
   💡

   Stale-While-Revalidate 전략

   캐시된 데이터를 먼저 보여주고, 동시에 백그라운드에서 새로운 데이터를 가져와 업데이트하는 전략입니다.

   </aside>

### 장점

- **빠른 로딩 속도** : 미리 생성된 HTML을 보여주므로, 로딩 시간을 단축할 수 있습니다.
- **데이터 실시간 반영** : 정해진 시간 간격으로 새로운 요청이 들어오면 페이지를 재생성하여 보여주므로, 데이터 변경을 반영할 수 있습니다.
- **서버 부하 감소** : 모든 요청에 대해 실시간으로 페이지를 생성하지 않으므로, 서버 부하를 줄일 수 있습니다.

### 단점

- **구현 복잡성** : 각 페이지의 상태를 관리해야 하므로, 관리 포인트가 증가할 수 있습니다.

---

## 13.6 Streaming SSR

HTML 파일을 작은 조각으로 나누어서 생성하여 전송하면 TTI, FCP를 더욱 단축시킬 수 있습니다.

Node.js의 스트림 기능을 사용하면 응답 객체에 데이터를 스트리밍할 수 있는데, 이는 클라이언트에 데이터를 지속적으로 전송할 수 있음을 의미합니다.

리액트에 내장된 `renderToNodeStream` 함수를 사용하면 애플리케이션을 작은 조각으로 나누어 전송할 수 있습니다.

클라이언트는 데이터를 받는 동시에 UI를 그리기 시작하여 빠른 초기 로딩을 제공할 수 있습니다.

---

## 13.7 React Server Components with SSR

RSC는 서버에서 실행되도록 설계된 상태를 가지지 않는 리액트 컴포넌트로, 서버 주도 방식으로 현대적인 사용자 경험을 제공합니다.

이러한 컴포넌트들은 번들 크기를 0으로 줄이고, 서버 컴포넌트와 클라이언트 컴포넌트 사이의 매끄러운 코드 전환 경험, 즉 니팅(knitting)을 가능하게 합니다.

---

## 13.8 엣지 SSR

CDN의 모든 지역에서 서버 렌더링을 가능하게 하고, 콜드 부트(함수가 처음 실행될 때 발생하는 지연 시간)시간을 거의 0에 가깝게 줄여줍니다.

사용자의 지역별 특화 리스트 페이지를 구축한다고 가정하면, 전체 페이지를 서버 렌더링하는 대신, 리스트 컴포넌트만 서버 사이드에서 렌더링하고 나머지는 엣지 사이드에서 렌더링하도록 선택할 수 있습니다.

## 13.9 점진적 하이드레이션

점진적 하이드레이션을 각 노드를 시간에 따라 개별적으로 하이드레이션하여 필요한 최소한의 자바스크립트만 요청하는 방식입니다.

점진적 하이드레이션은 애풀리케이션을 여러 조각으로 나누어 뛰어난 성능을 제공하는 것 을 목표로 합니다.

상대적으로 덜 중요한 부분의 하이드레이션을 지연시켜 페이지를 상호작용할 수 있게 만드는 데 필요한 자바스크립트 양을 줄이고, 빠르게 필요한 노드만 하이드레이션할 수 있습니다.

리액트의 동시성 모드는 여러 작업을 동시에 처리하면서 우선순위에 따라 작업 간 전환을 가능하게 합니다.

동시성 모드로 점진적 하이드레이션을 구현한다면, 사용자 입력과 같은 높은 우선순위의 작업이 필요하면 하이드레이션을 일시 중지하고 입력을 받아들이는 작업으로 전환할 수 있습니다.

# 14. 리액트 애플리케이션 구조

리액트에서 파일을 그룹화하는 방법은 크게 두 가지가 있습니다.

- 기능별 그룹화
  각 애플리케이션 모듈, 기능 또는 경로별로 폴더를 만듭니다.
- 파일 유형별 그룹화
  css, js, 이미지 등 파일 유형별로 폴더를 만듭니다.
