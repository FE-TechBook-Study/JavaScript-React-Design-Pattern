# 렌더링 패턴

## CSR

- 대부분의 애플리케이션 로직이 클라이언트에서 실행됨
- 데이터는 API를 통해 서버와 상호작용
- UI가 클라이언트에서 생성되며, 전체 웹 앱이 처음 요청 시 모두 로드됨
- 장점: 페이지 새로고침 없는 탐색, 빠른 페이지 간 라우팅
- 단점: 큰 JavaScript 번들 크기로 인한 초기 로딩 시간 증가, SEO 어려움

## SSR

- 모든 요청마다 서버에서 HTML을 새로 생성
- 사용자 쿠키 정보나 요청 데이터 기반의 동적/개인화된 페이지에 적합
- 데이터 fetching과 HTML 생성이 서버에서 처리됨
- 클라이언트에서는 하이드레이션 과정 필요
- 장점: 빠른 초기 로딩, 좋은 SEO
- 적합한 사례: 개인화된 대시보드, 인증이 필요한 페이지

## Static Rendering

- 빌드 시점에 전체 페이지의 HTML을 미리 생성
- CDN이나 엣지 네트워크에서 캐싱 가능
- 자주 변경되지 않는 콘텐츠에 적합
- 변형:
  - 데이터베이스의 정적 데이터를 활용한 리스트 페이지 생성
  - 동적 경로를 사용한 상세 페이지 생성
  - 클라이언트 사이드 데이터 fetching 결합
- 적합한 사례: 회사 소개, 블로그, 제품 페이지

## Streaming SSR

- HTML을 작은 조각(청크)으로 나누어 점진적으로 전송
- 클라이언트는 데이터를 받는 즉시 렌더링 시작 가능
- 네트워크 정체 현상에 효과적
- React의 renderToNodeStream 함수 활용

## Edge Rendering

- CDN의 모든 지역에서 서버 렌더링 가능
- 콜드 부트 시간을 거의 0에 가깝게 줄임
- HTTP 스트리밍 지원
- 적합한 사례: 지역 특화 리스트 페이지

## Hybrid Rendering

- 여러 렌더링 방식을 상황에 맞게 결합
- 정적으로 제공 가능한 페이지는 미리 렌더링
- 동적인 페이지는 SSR이나 CSR 활용
- 각 페이지에 맞는 렌더링 모드를 유연하게 선택 가능
- Next.js 13, Astro 2.0, Angular Universal 등이 지원

## Progressive Hydration

- 각 노드를 시간에 따라 개별적으로 하이드레이션하고 최소한의 자바스크립트만 요청
- 주요 요구사항:
  - 모든 컴포넌트에 SSR 사용 가능
  - 개별 컴포넌트/조각 단위로 코드 스플리팅 지원
  - 개발자가 정의한 순서대로 하이드레이션 지원
  - 이미 하이드레이션된 조각에서 사용자 입력 가능 상태 유지
  - 지연된 하이드레이션이 적용되는 조각에 로딩 표시 가능
- React의 동시성 모드를 통해 구현 가능

## Islands Architecture

- 정적 HTML 위에 독립적으로 상호작용 가능한 "아일랜드" 배치
- 특징:
  - 자바스크립트 전송량 감소
  - 정적/동적 아일랜드로 페이지 구분
  - 각 컴포넌트가 자체적으로 하이드레이션
- 지원하는 프레임워크:
  - Marko (eBay)
  - Astro
  - Eleventy + Preact
- 장점:
  - 성능 향상 (작은 JavaScript 번들)
  - SEO 최적화
  - 중요 콘텐츠 우선순위
  - 접근성 향상
  - 컴포넌트 기반 재사용성
- 단점:
  - 구현에 추가 노력 필요
  - 소셜 미디어 앱처럼 상호작용이 많은 페이지에는 부적합

## React Server Component

- 서버에서 실행되도록 설계된 상태가 없는 React 컴포넌트
- 특징:
  - async/await를 사용한 데이터 fetching
  - 서버와 클라이언트 컴포넌트 매끄러운 통합
  - 클라이언트 사이드 JavaScript 번들 크기 감소
- Next.js App Router와의 통합:
  - app 디렉토리의 컴포넌트는 기본적으로 RSC로 설정
  - 'use client' 지시문으로 클라이언트 컴포넌트 지정
  - 서버와 클라이언트 컴포넌트 혼합 사용 가능
  - 실제 프로덕션 환경에서 성능 향상 확인
