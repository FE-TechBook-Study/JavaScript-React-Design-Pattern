# 민지

## 13.1 렌더링 패턴의 중요성

뛰어난 사용자 경험을 제공하기 위해서는, 핵심 웹 지표(CWB)와 같은 사용자 중심 지표를 기준으로 애플리케이션을 최적화해야한다.

- TTFB
    - 클라이언트가 페이지 콘텐츠의 첫 번째 바이트를 받는데 걸리는 시간
- FCB
    - 페이지 이동 후 브라우저가 콘텐츠의 첫 부분을 렌더링하는 데 걸리는 시간
- TTI
    - 페이지 로드 시작부터 사용자 입력에 빠르게 응답할 수 있을 때까지 걸리는 시간
- LCP
    - 페이지의 주요 콘텐츠를 로드하고 렌더링하는 데 걸리는 시간
- CLS
    - 예상치 못한 레이아웃 변경을 방지하기 위한 시각적 안정성 측정
- FID
    - 사용자가 페이지와 상호작용한 시점부터 이벤트 핸들러가 실행될 수 있는 시점까지의 시간

CWV 지표는 사용자 경험과 가장 관련이 높은 요소들을 측정한다. CWB를 최적화하면 뛰어난 사용자 경험과 검색 엔진 최적화를 보장할 수 있다.

## 13.2 클라이언트 사이드 렌더링

- CSR은 페이지 새로고침 없이 탐색을 지원하는 SPA를 구축할 수 있게 하여 뛰어난 사용자 경험을 제공한다. 이로 인해 반응성이 더 뛰어난 것처럼 보인다.
- 하지만 페이지의 복잡성이 증가하면 페이지 렌더링에 필요한 자바스크립트 코드의 복잡성과 크기도 증가한다. CSR은 큰 자바스크립트 번들을 만들도록 하여 페이지의 FCP와 TTI를 증가시킨다. 또한 큰 요청 객체와 API 응답과 같은 일련의 네트워크 요청으로 인해 크롤러가 색인하기 전에 의미있는 콘텐츠가 시간에 맞춰 렌더링되지 않을 수 있어 웹사이트의 SEO에 영향을 미칠 수 있다.

## 13.3 서버 사이드 렌더링

- 요청마다 서버에서 HTML을 만들어서 보낸다.
- 개인화된 데이터나 인증 상태에 따라 화면을 다르게 보여줄 때 적합하다.
- 웹 콘텐츠 렌더링 방식 중 가장 오래된 방식이다.
- **작동 방식**
    - 서버에서 데이터를 가져오고 템플릿을 처리해 완전한 HTML을 만든다.
    - 클라이언트에 자바스크립트 코드 전달을 최소화한다.
- **장점**
    - 데이터 처리와 화면 구성이 서버에서 끝나니 추가 작업이 줄어든다.
    - 클라이언트가 처리해야 할 부담이 적다.
- **단점**
    - 모든 요청을 새로 처리하니 서버 부담이 크다.
    - 클라이언트에서 하이드레이션(상태 복구) 과정이 추가로 필요하다.

## 13.4 정적 렌더링

- HTML을 빌드 시점에 미리 생성해 저장하며, 다음 빌드까지 변경되지 않는다.
- CDN이나 엣지 네트워크를 통해 캐싱되어 빠르게 제공된다.
- 요청마다 HTML을 생성하는 SSR보다 빠르다.
- **적합한 경우**
    - 자주 변경되지 않고 요청자에 상관없이 동일한 콘텐츠를 보여주는 페이지에 적합.
    - 예: 회사 소개, 문의하기, 블로그, 상품 페이지 등.
- **활용 패턴**
    1. **동적 데이터를 활용한 정적 리스트 페이지**
        - 정적 데이터를 기반으로 리스트 페이지 생성.
        - Next.js에서 `getStaticProps()` 또는 `fetch`의 `cache` 옵션 사용.
    2. **동적 경로를 사용한 상세 페이지**
        - 동적 데이터를 템플릿에 채워 상세 페이지 생성.
        - Next.js에서 `getStaticPaths()`나 `generateStaticParams()` 활용.
    3. **클라이언트 사이드 데이터 fetching**
        - 정적 HTML 뼈대와 함께 데이터를 클라이언트에서 가져온다.
        - 최신 데이터 표시가 필요한 동적 리스트 페이지에 유용.
        - Next.js와 SWR(Hook 라이브러리)을 조합해 사용.
- **장점**
    - 빠른 로딩 속도.
    - 정적 HTML은 안정적이고 캐싱이 쉬움.
- **단점**
    - 빌드 이후 콘텐츠가 변경되지 않음.
    - 요청 기반 데이터에는 적합하지 않음.

## 13.6 엣지 SSR

- CDN의 각 지역에서 서버 사이드 렌더링을 수행하여 사용자 가까운 곳에서 콘텐츠를 제공한다.
- 콜드 부트 시간을 거의 없애고 빠른 초기 응답을 가능하게 한다.
- HTTP 스트리밍을 지원하여 준비된 콘텐츠를 즉시 전송하고, 컴포넌트를 개별적으로 하이드레이션하여 최초 콘텐츠 표시 시간(FCP)을 단축한다.
- 엣지 네트워크를 활용하여 빠르고 효율적으로 콘텐츠를 제공하며, 사용자 경험을 크게 향상시킨다.

## 13.7 하이브리드 렌더링

- 여러 렌더링 방식을 결합해 상황에 맞는 최적의 결과를 제공하는 접근 방식이다.
- 정적으로 제공 가능한 페이지는 미리 렌더링하고, 동적 페이지에는 **ISR**, **SSR**, **CSR**, 스트리밍 등의 전략을 사용한다.
- 기존의 **SPA**, **MPA**, **SSR**, **SSG** 틀에서 벗어나 다양한 렌더링 모드를 조합한다.
- **장점**
    - SPA의 장점을 유지하면서도 페이지 새로고침 없이 네비게이션이 가능하다.
    - 각 페이지의 요구에 따라 렌더링 방식을 유연하게 선택할 수 있다.
    - 개발 초기에는 CSR로 시작하고, 이후 필요에 따라 SSR이나 다른 렌더링 모드를 추가할 수 있다.
- 웹 애플리케이션 개발 패러다임의 변화를 반영하며, 더 유연하고 다재다능한 접근 방식을 가능하게 한다.
- 특정 렌더링 방식에 얽매이지 않고, 필요에 따라 조합하여 사용한다.

## 13.10 리액트 서버 컴포넌트

- 서버에서 실행되도록 설계된 상태가 없는 리액트 컴포넌트
- 서버 주도 방식으로 현대적인 사용자 경험을 제공하며 클라이언트로 전송하는 자바스크립트 번들을 최소화한다.
- **번들 크기 감소**: RSC를 사용하면 클라이언트 번들 크기를 0에 가깝게 줄인다.
- **데이터 fetching 통합**: `async/await`로 서버 컴포넌트에서 데이터를 가져오며, 데이터를 직렬화해 컴포넌트 트리에 통합한다.
- **RSC 프로토콜**: 서버가 클라이언트 요청에 따라 특정 컴포넌트를 제공하며 SPA와 같은 라우팅을 구현한다.
- **SSR과의 조합**: RSC는 SSR을 대체하지 않으며, 함께 사용해 초기 렌더링 속도를 더욱 빠르게 유지할 수 있다.
- 클라이언트 사이드의 상호작용과 서버 사이드 렌더링의 성능을 결합한다.
- 서버 컴포넌트를 통해 필요한 데이터만 클라이언트로 전송하여 효율을 높인다.

### 13.10.1 RSC와 Next.js App Router를 활용한 하이브리드 렌더링

- **App Router 도입 -** 새로운 라우터와 함께 **RSC(리액트 서버 컴포넌트)** 지원을 기본으로 제공한다.
- **자동 서버 컴포넌트 설정 -** `app` 디렉토리 내 컴포넌트는 기본적으로 서버 컴포넌트로 렌더링되어 성능이 향상된다.
- **RSC**
    - 서버 인프라를 활용해 대용량 의존성을 서버에 유지하여 클라이언트 번들 크기를 줄인다.
    - 성능을 최적화하며 클라이언트와 서버 간의 매끄러운 상호작용을 지원한다.
- **클라이언트 컴포넌트 사용 방법**
    - **`"use client"` 지시문**: 클라이언트 컴포넌트를 선언할 때 사용.
    - 클라이언트 컴포넌트 없이 import되지 않은 컴포넌트는 서버 컴포넌트로 처리된다.
