# 1. TTFB

참고 자료:

1. https://web.dev/articles/ttfb?hl=ko

## TTFB란

리소스 요청과 응답의 첫 번째 바이트가 도착하기 시작하는 시점 사이의 시간을 측정하는 측정항목이다.

웹 서버가 요청에 응답하기에 너무 느린 경우를 식별하는 데 도움이 된다.

![스크린샷 2024-12-08 14.28.36.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/a43c8b7f-e77d-47de-a59c-f74de1fb0eee/39e999e9-1694-4336-bb9b-0949ca7a1440/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-12-08_14.28.36.png)

TTFB는 다음 요청 단계의 합계이다.

- 리디렉션 시간
- 서비스 워커 시작 시간 (해당 하는 경우)
- DNS 조회
- 연결 및 TLS 협상
- 응답의 첫 번째 바이트가 도착할 때까지의 요청

연결 설정 시간과 배엔드의 지연 시간을 줄이면 TTFB가 줄어들 수 있다.

# 1. 정적 렌더링 vs 서버 사이드 렌더링

참고 자료:

1.  https://medium.com/@crp_underground/server-side-rendering-ssr-vs-static-site-generation-ssg-in-next-js-72b086a373e6
2.  https://nextjs.org/docs/app/api-reference/functions/generate-static-params

## 서버 사이드 렌더링 (SSR)

서버 처리 시간이 늘어나는 만큼 TTFB에 부정적인 영향을 줄 수 있다.

## 정적 렌더링 (SSG)

빌드할 때 미리 렌더링해 둔 HTML 자체를 서빙하여 번들 크기가 늘어나는 문제(CSR)와 서버 처리 시간이 늘어나는 문제(SSR)를 해결한다.

사용자가 접속할 수 있는 각 라우팅 경로에 대응하는 HTML 파일들이 미리 생성된다. 이런 HTML 파일들은 클라이언트 측 요청에 대해 서버나 CDN에서 서빙될 수 있다.

HTML 파일들을 미리 생성하고 사용하기 때문에 서버가 요청을 받았을 때의 처리 시간은 거의 무시할 수 있는 수준이며, 결과적으로 빠른 TTFB와 좋은 성능을 보인다.

이상적으로는 클라이언트 측 자바스크립트가 최소화 되고 페이지를 다운로드 받자 마자 인터렉티브가 가능하게 된다.

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/a43c8b7f-e77d-47de-a59c-f74de1fb0eee/e13fd816-f070-4bc0-83be-d013e09cd143/image.png)

따라서 SSG는 빠른 FCP/TTI를 달성할 수 있게 된다.

### SSG - 기본 구조

정적 렌더링은 ‘소개’, ‘연락처’, 블로그 페이지와 같은 정적 콘텐츠에 적합하다.

### 데이터를 포함한 SSG

각각의 블로그 포스트들은 빌드 시점에 데이터 스토어로부터 불러온 데이터와 HTML로 렌더링 될 템플릿들과 병합 되어야 한다.

- page router:
  - **`getStaticProps`**: **빌드 타임**에 실행되어 외부 데이터 소스를 호출하고, 해당 데이터를 페이지 컴포넌트에 전달
  - **`getStaticPaths`**: 함수를 **빌드 타임**에 각각의 블로그 상세 페이지를 pre-render할 때 필요한 상세 페이지 번호를 반환한다.
- app router:
  - **`generateStaticParams` :** 동적 경로(dynamic routes)를 가진 페이지에서, **빌드 타임**에 생성할 모든 경로를 정의한다. (`getStaticPaths` 와 유사)
  - **정적 데이터 생성:** 빌드 시점에 데이터를 가져오기 위해 `fetch` 호출에 `{ cache: 'force-cache' }`를 설정

### SSG - 주요 고려사항

SSG를 사용하면 클라이언트와 서버 양쪽의 처리량을 줄여주어 좋은 성능을 확보할 수 있고, 검색엔진에도 최적화되어 있다.

그러나 SSG를 적용하기 전에 아래 사항들을 한 번 확인해볼 필요가 있다.

1. HTML 파일이 아주 많은 경우
   1. 미리 HTML 파일들을 만들어야 하므로, 최초 생성 이후 포스트가 수정되면 해당 포스트 관련 파일들을 모두 다시 빌드해야 한다. 대량의 HTML 파일을 관리하는 게 까다로울 수 있다.
2. 호스팅 의존성
   1. 응답 속도를 위해 호스팅 플랫폼 사용하는 것도 좋은 방법. 여러 CDN에서 콘텐츠가 서빙되도록 세팅하면 최고의 성능을 이끌어 낸다.
3. 동적 콘텐츠
   1. 콘텐츠가 변경될 때마다 매번 새로 빌드해야 한다. 콘텐츠 변경 이후 배포하지 않으면 이전 콘텐츠가 계속 보여질 수 있다. 자주 변경되어야 하는 콘텐츠에 대해 SSG를 적용하는 것은 적합하지 않다.

# 2. 점진적 하이드레이션

참고 자료:

1. https://patterns-dev-kr.github.io/rendering-patterns/progressive-hydration/

서버 사이드에서 렌더링된 애플리케이션은 현재 페에지를 위한 HTML을 생성하기 위해 서버를 사용한다.

서버에서 HTML 콘텐츠 생성(CSS와 정적 UI에 보여줄 JSON 데이터 포함)이 완료되면, 클라이언트에 데이터를 보낸다.

서버가 이미 우리(클라이언트)에게 마크업을 생성해주었으니, 클라이언트는 이를 빠르게 파싱하여 화면에 보여줄 수 있고, 이것은 빠른 FCP(First Contentful Paint) 를 만들어낸다.

그러나, 이것이 항상 빠른 TTI(Time To Interactive)를 제공하는 거승ㄴ 아니다.

우리 웹사이트와 상호작용하기 위한 필수 자바스크립트 번들이 아직 로드되지 않았기 때문이다.

버튼이 인터렉티브하게 보일지라도, 아직 상호작용할 수 없다.

자바스크립트 번들이 로드되고 처리되어져야만 핸들러가 적용된다.

이 과정을 하이드레이션(Hydration)이라고 한다.

- 리액트가 현재 DOM 노드들을 확인하고, 각 노드에 상응하는 자바스크립트를 하이드레이트한다.

유저가 화면에서 비상호작용적인 UI를 보게되는 시점을 불쾌한 골짜기(uncanny valley)라고 일컫는다.

이는, 유저가 상호작용가능할거라 생각했던 요소가, 실제로는 아직 핸들러가 적용되지 않아 상호작용할 수 없고, 유저 경험을 저하시키는 현상을 가리킨다.

서버에서 전달받은 DOM 컴포넌트가 완전히 hydrate 되기까지 시간이 걸릴 수 있다.

컴포넌트를 hydrate하기 위해서는 자바스크립트 파일이 로드되고, 처리되고, 실행되는 과정을 거쳐야 한다.

이전에는 애플리케이션을 한 번에 hydrate 했지만, DOM 노드를 점진적으로(progressively) hydrate 하는 방법도 사용할 수 있다.

**점진적 하이드레이션은 DOM 노드 개별적으로 시간을 두고 하이드레이트할 수 있으므로, 필요한 최소한의 자바스크립트만 요청할 수 있게 된다.**

## 점진적 하이드레이션의 장점

1. 페이지에서 덜 중요한 부분의 하이드레이션을 지연시킴으로써, 자바스크립트 양을 줄인다.
2. **서버에서 렌더링된 DOM 트리가 파괴된 후 즉시 다시 생성되는 일반적인 SSR 하이드레이션 문제**를 방지하는데 도음을 준다.
   - 부연 설명
     **서버와 브라우저(클라이언트)가 생각하는 화면 구조가 맞지 않을 때** 발생한다. React는 이런 경우, "오, 뭔가 잘못됐네!" 하고, 서버에서 만든 화면을 **싹 지우고 새로 만든다.**
     ### **전통적인 방식 (문제 발생 예시):**
     - 서버: `<div><h1>안녕하세요!</h1><p>로그인하세요.</p></div>`
     - 클라이언트: "로그인 정보가 있으니 `<p>`를 바꿔야겠네!" → `<div><h1>안녕하세요!</h1><p>환영합니다, 최소희 님!</p></div>`
       React는 "어? 서버에서 받은 `<p>`랑 내가 필요한 `<p>`가 다르잖아!" → **전체 `<div>`를 지우고 새로 생성.**
     ***
     ### **점진적 하이드레이션:**
     - 서버: `<div><h1>안녕하세요!</h1><p>로그인하세요.</p></div>`
     - 클라이언트: "음, 상단의 `<h1>`은 괜찮고, `<p>`는 데이터 받을 때만 바꾸자." → **서버에서 받은 HTML을 그대로 유지**하고, `<p>`만 나중에 업데이트.
       결과적으로:
     - 화면 깜빡임 없음.
     - 서버에서 만든 구조를 최대한 재활용.
     - 초기 화면이 빠르게 상호작용 가능.

## 점진적 하이드레이션 구현

하이드레이션은 클라이언트 측 React가 서버에서 렌더링된 ReactDOM 컴포넌트를 인식하고, 이 컴포넌트들에 이벤트를 연결할 수 있게 해준다. 따라서, SSR 애플리케이션이 클라이언트에서 CSR 애플리케이션처럼 동작하도록 연속성과 매끄러운 전환을 제공한다.

페이지의 모든 컴포넌트를 하이드레이션하여 상호작용 가능하게 만들기 위해, 이러한 컴포넌트에 대한 React 코드는 클라이언트로 다운로드되는 번들에 포함되어야 한다.

**자바스크립트로 대부분이 제어되는 상호작용적인 SPA는 전체 번들이 한 번에 필요하나,**

**화면에 몇 가지 상호작용 요소가 있는 정적인 웹사이트는 모든 컴포넌트가 즉시 활성화될 필요가 없다.**

**이를 위해, 방대한 번들을 보내는 것은 부담이 된다.**

**점진적 하이드레이션은 페이지 로드 시, 애플리케이션의 특정 부분만 하이드레이션**하여 이러한 문제를 해결한다.

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/a43c8b7f-e77d-47de-a59c-f74de1fb0eee/e9dc9da9-b0ef-46e7-913b-eb3d5f9d7a26/image.png)

Other Content와 You may also like는 점진적 하이드레이션에 의해, 나중에 하이드레이트 된다.

점진적 하이드레이션의 핵심은 청크 단위로 앱을 활성화시킴으로써 좋은 성능을 제공하는 것이다.

청크들이 순차적으로 화면에 나타나는 동안, 이미 로드된 청크에서 활동이나 사용자 입력이 차단되도록 하면 안된다.

### 점진적 하이드레이션의 전반적인 구현으로 위한 요구사항

1. 모든 컴포넌트에 대해 SSR을 사용할 수 있어야 한다.
2. 코드를 개별 컴포넌트나 청크로 분리하는 것을 지원해야 한다. (코드 스플리팅)
3. 개발자가 정의한 순서대로 클라이언트에서 이러한 청크를 하이드레이션하는 것을 지원해야 한다.
4. 이미 하이드레이션된 청크에서 사용자 입력이 차단되지 않아야 한다.
5. 하이드레이션이 지연된 청크에 대해 로딩 표시기를 사용할 수 있어야 한다.

[리액트의 Cocurrent Mode(동시성 모드)](https://17.reactjs.org/docs/concurrent-mode-patterns.html)는 이러한 요구사항을 해결하며, 여러 작업을 동시에 처리하고 우선순위에 따라 작업 간 전환하는 기능을 제공한다.

> React 18부터는 모드가 아닌, 개발자의 선택으로 동시성이 적용된다.
>
> - **`ReactDOM.createRoot()`**: 동시성 활성화의 기본.
> - **`startTransition` 및 `useTransition`**: 낮은 우선순위 작업 처리.
> - **`Suspense` 및 `SuspenseList`**: 지연 로드와 컴포넌트 로딩 순서 제어.
> - **Server Components**: 서버에서 데이터를 스트리밍하며 클라이언트 렌더링 최적화.

리액트의 동시성은 점진적 하이드레이션을 처리할 수 있는 메커니즘을 제공한다.

페이지를 청크(작은 조각)로 나누어 처리하고, 각 청크의 하이드레이션 작업을 독립적으로 관리한다.

우선순위가 높은 작업(예: 사용자 입력)이 있으면 하이드레이션을 멈추고 즉시 처리한다.

`lazy` 와 `Suspense` 는 컴포넌트를 동적으로 로드하면서 로딩 상태를 명확하게 표현할수 있는 도구이다.

청크가 로드되는 동안 사용자에게 로딩상태를 시각적으로 알릴 수 있다.

`SuspenseList()`를 사용해 어떤 컴포넌트를 먼저 로드할지 설정할 수 있다.

서버 컴포넌트를 결합하면, 데이터를 한 번에 가져오지 않고, 스트리밍 방식으로 클라이언트에서 컴포넌트를 순차적으로 렌더링할 수 있다.

따라서, 네트워크 지연이 발생해도 클라이언트의 CPU를 활용해 작업 효율성을 높일 수 있다.

## 점진적 하이드레이션의 장,단점

코드 스플리팅, 필요 시 로딩, 번들 크기 감소와 같은 장점을 제공하여 성능과 효율성을 높인다.

그러나, 모든 요소가 초기 로드 시 상호작용 가능해야 하는 동적 애플리케이션에서는 적합하지 않을 수 있다.

어떤 컴포넌트를 먼저 하이드레이션할지 결정할 수 밖에 없는 상황에서는 이 방식이 한계에 부딪힐 수 있다.

# 3. 선택적 하이드레이션 (Selective Hydration)

참고 자료:

1. https://github.com/reactwg/react-18/discussions/37
2. https://www.patterns.dev/react/react-selective-hydration

- 참고자료 1 원문 번역 (GPT)
  ### **React 18의 SSR(서버 사이드 렌더링) 개선 사항 요약**
  React 18은 SSR(Server-Side Rendering) 성능을 크게 향상시키는 두 가지 주요 기능을 제공합니다. 이 기능들은 를 중심으로 작동하며, 앱을 더 빠르게 렌더링하고 상호작용을 개선합니다.
  ***
  ### **1. 주요 기능**
  ### **1-1. 스트리밍 HTML (Streaming HTML)**
  - **기능:** HTML을 서버에서 점진적으로 스트리밍하여, 모든 데이터가 준비되기 전에 일부 HTML을 먼저 전송합니다.
  - **장점:**
    - 초기 로딩 시간을 줄이고, 빠르게 페이지의 뼈대를 표시할 수 있습니다.
    - 서버에서 HTML을 전송하면서, 필요한 JavaScript `<script>` 태그를 포함하여 클라이언트에서 HTML이 올바른 위치에 렌더링되도록 합니다.
  ### **1-2. 선택적 하이드레이션 (Selective Hydration)**
  - **기능:** 클라이언트에서 HTML과 JavaScript를 모두 로드하기 전에, 앱의 특정 부분만 먼저 하이드레이션할 수 있습니다.
  - **장점:**
    - 사용자가 상호작용하는 부분을 우선적으로 하이드레이션하여 빠른 응답성을 제공합니다.
    - 대규모 컴포넌트가 전체 페이지를 차단하지 않도록 하여, 성능과 사용자 경험을 개선합니다.
  ***
  ### **2. SSR의 기존 문제와 해결**
  ### **문제 1: 모든 데이터를 가져와야 HTML을 렌더링할 수 있음**
  - **기존 문제:**
    - 서버에서 모든 데이터를 가져오기 전에는 HTML을 클라이언트로 전송할 수 없었습니다.
    - 데이터 로드 지연이 전체 페이지 렌더링을 방해했습니다.
  - **React 18 개선:**
    - <Suspense>를 활용해 데이터를 기다리는 부분만 플레이스홀더(로딩 표시)로 대체하고, 나머지 HTML은 먼저 스트리밍합니다.
  ### **문제 2: 모든 JavaScript를 로드해야 하이드레이션 가능**
  - **기존 문제:**
    - 클라이언트에서 모든 JavaScript를 로드하기 전에는 하이드레이션이 시작되지 않았습니다.
  - **React 18 개선:**
    - 코드 스플리팅과 를 결합하여, 특정 컴포넌트의 JavaScript 코드가 없어도 하이드레이션을 시작할 수 있습니다.
  ### **문제 3: 모든 컴포넌트를 하이드레이션해야 상호작용 가능**
  - **기존 문제:**
    - 모든 컴포넌트를 하이드레이션하기 전까지는 페이지와 상호작용할 수 없었습니다.
  - **React 18 개선:**
    - <Suspense>를 사용해 특정 컴포넌트만 선택적으로 하이드레이션하여, 사용자가 클릭하거나 상호작용한 부분을 우선적으로 처리합니다.
  ***
  ### **3. 주요 API 및 예제**
  ### **3-1. 스트리밍 HTML 예제**
  - **기존 SSR:** 모든 HTML과 데이터를 가져와야 렌더링 가능.
  - **React 18:** 로 감싼 부분은 로딩 표시(Spinner)를 보여주고, 나머지 HTML은 즉시 스트리밍.
  ```jsx
  <Layout>
    <NavBar />
    <Sidebar />
    <RightPane>
      <Post />
      <Suspense fallback={<Spinner />}>
        <Comments />
      </Suspense>
    </RightPane>
  </Layout>
  ```
  - `Comments`가 준비되지 않아도, `NavBar`와 `Post`는 먼저 렌더링됩니다.
  - 데이터가 준비되면 `Comments`의 HTML이 스트리밍으로 추가됩니다.
  ***
  ### **3-2. 선택적 하이드레이션 예제**
  - **기능:** 사용자가 상호작용한 부분을 우선 하이드레이션.
  - **예제 코드:**
  ```jsx
  <Suspense fallback={<Spinner />}>
    <Comments />
  </Suspense>
  ```
  - `Comments`의 JavaScript가 로드되기 전에 페이지의 나머지 부분은 이미 하이드레이션되어 상호작용 가능합니다.
  - JavaScript가 로드된 이후에 `Comments`는 하이드레이션되어 즉시 상호작용 가능해집니다.
  ***
  ### **4. React 18의 SSR 기능의 주요 이점**
  1. **HTML 전송이 더 빨라짐:**
     - 데이터를 기다리지 않고 먼저 전송 가능한 HTML을 제공.
     - 를 활용해 특정 컴포넌트는 나중에 HTML을 스트리밍.
  2. **하이드레이션이 더 효율적:**
     - 모든 JavaScript를 로드할 필요 없이, 선택적으로 하이드레이션 가능.
     - 무거운 JavaScript 컴포넌트가 전체 페이지 하이드레이션을 방해하지 않음.
  3. **빠른 상호작용 가능:**
     - 사용자 상호작용에 따라 하이드레이션 우선순위를 조정.
     - 특정 컴포넌트가 준비되지 않아도 나머지 페이지는 즉시 상호작용 가능.
  ***
  ### **5. 결론**
  React 18의 **Streaming HTML**과 **Selective Hydration** 기능은 SSR의 기존 문제를 크게 개선합니다.
  이제 모든 데이터를 기다리거나, 모든 JavaScript를 로드하거나, 모든 컴포넌트를 하이드레이션하지 않아도 됩니다.
  이 기능들은 컴포넌트를 통해 사용 가능하며, 대부분의 기존 React 코드는 별도의 변경 없이도 작동합니다.
  React 18은 성능과 사용자 경험의 새로운 표준을 제시합니다.

## 기존 SSR과 하이드레이션의 한계

전통적인 SSR은 `renderToString` 메서드를 사용해 서버에서 전체 컴포넌트 트리를 HTML로 변환한 후 클라이언트로 전송한다.

이때, 모든 컴포넌트가 준비될 때까지 기다려야 하므로, 외부 API 호출 등으로 인해 지연이 발생하면 작은 컴포넌트들도 함께 지연된다.

또한, 리액트는 전체 자바스크립트 번들이 로드될 때까지 하이드레이션을 시작하지 않기 때문에, 작은 컴포넌트들도 큰 컴포넌트의 코드 로드를 기다려야 하며, 이 기간 동안 웹사이트는 비활성 상태로 남게 된다.

## React 18의 선택적 하이드레이션

React 18에서는 이러한 문제를 해결하기 위해 **스트리밍 서버 사이드 렌더링과 선택적 하이드레이션을** 도입했다.

`renderToString` → `pipeToNodeStream` 메서드로 변경하여, 서버에서 HTML을 스트리밍 방식으로 렌더링할 수 있다.

`createRoot` 메서드와 `Suspense` 컴포넌트를 함께 사용하면, 큰 컴포넌트가 준비될 때까지 기다리지 않고도 HTML 스트리밍을 시작할수 있다.

즉, SSR을 사용할 때도 컴포넌트를 지연 로드(lazy-load)할 수 있게 되었다.

예를 들어, `Comments` 컴포넌트가 트리 생성과 TTI를 지연시키는 경우, 이를 `Suspense`로 감싸면 React는 이 컴포넌트가 나머지 트리 생성을 지연시키지 않도록 처리한다.

대신, React는 초기 렌더링 시 폴백(fallback) 컴포넌트를 삽입하고, 나머지 트리를 생성하여 클라이언트로 전송한다.

이 동안, `Comments` 컴포넌트에 필요한 외부 데이터를 가져오고, 데이터가 준비되면 React는 해당 컴포넌트의 HTML과 작은 `<script>` 를 스트리밍하여 폴백 로더를 대체한다. 새로운 HTML이 주입된 후 React는 하이드레이션을 시작한다.

## 선택적 하이드레이션의 장점

React1 18의 선택적 하이드레이션은 SSR 사용 시 발생하던 문제(서버에서 생성이 오래 걸리던 문제)를 해결한다.

스트리밍 렌더링을 통해 컴포넌트가 준비되는 즉시 스트리밍할 수 있어, FCP와 TTI가 지연되는 위험을 줄인다.

또한, 모든 자바스크립트가 로드될 때까지 기다릴 필요 없이, 클라이언트로 스트리밍된 컴포넌트를 즉시 하이드레이션하여 애플리케이션과 상호작용할 수 있다.

# 4. 하이드레이션 SSR vs 스트리밍 SSR

## 1. 하이드레이션 SSR

- 하이드레이션 SSR === 전통적인 SSR
- 서버에서 전체 HTML을 렌더링하고 클라이언트로 전송한 후, 클라이언트가 자바스크립트 번들을 로드하고 HTML에 이벤트 핸들러를 연결(하이드레이션)하여 페이지를 상호작용 가능하게 만든다.
- **특징**
  - 클라이언트에서 하이드레이션이 완료될 때까지 페이지의 모든 컴포넌트는 비활성 상태.
  - 모든 데이터를 준비하고 렌더링 결과를 한 번에 클라이언트로 보내야 함.
  - TTFB 이후에도 상호작용까지 시간이 더 걸림.
- **장점**
  - 간단한 구조: 모든 데이터를 준비하고, 한번에 HTML을 전송하는 방식.
  - SEO 최적화: 서버에서 완전한 HTML을 생성하므로, 검색 엔진이 페이지를 쉽게 인덱싱.
- **단점**
  - 효율성 문제: 서버에서 모든 데이터를 준비하고, 모든 JavaScript가 로드되어야만 페이지가 상호작용 가능.
  - 로딩 지연: 데이터 로딩이나 대규모 JavaScript 번들로 인해 초기 상호작용이 느려질 수 있음.

## 2. 스트리밍 SSR

- React 18에서 도입된 개선된 SSR 방식.
- 서버에서 HTML을 “스트리밍” 방식으로 점진적으로 전송하여, 데이터를 모두 기다리지 않고 가능한 부분부터 즉시 렌더링.
- 클라이언트에서는 선택적 하이드레이션을 통해 필요한 부분만 우선적으로 상호작용 가능하게 만듦.
- **특징**
  - <Suspense> 컴포넌트를 활용해 데이터가 준비되지 않은 부분에는 플레이스홀더(예: 로딩 스피너)를 표시.
  - 준비된 데이터가 있는 HTML은 먼저 전송되고, 나머지 데이터는 준비되는 대로 스트리밍.
  - 클라이언트에서 하이드레이션 우선순위를 지정 가능.
  - 네트워크가 혼잡하여 더 이상 데이터를 전송할 수 없는 경우, 렌더러는 이를 감지하고 네트워크가 원활해질 때까지 스트리밍을 중단함. 이를 통해, 서버는 더 적은 메모리를 사용하여, I/O 조건에 더욱 민감하게 반응할 수 있음.
    - Node.js 서버가 여러 요청을 동시에 렌더링할수 있게 해주며,더 무거운 요청이 가벼운 요청을 오랫동안 차단하지 않도록 방지함.
- **장점**
  - 빠른 초기 렌더링: 데이터 준비 상태에 따라 HTML을 점진적으로 전송하여, 사용자에게 빠르게 콘텐츠를 제공.
  - 효율적인 리소스 활용: 선택적 하이드레이션으로 JavaScript 로드가 지연되는 부분이 전체 페이지 상호작용을 차단하지 않음.
  - 동적 데이터 처리: 서버에서 데이터를 기다리지 않고, 준비된 부분부터 순차적으로 렌더링 가능.
- **단점**
  - 구현 복잡성: 기존 SSR보다 <Suspense>와 같은 추가적인 설계를 요구.
  - 데이터 통합 필요: 데이터 페칭 라이브러리가 <Suspense>와 통합되어야 최대 효율 발휘.

# 5. 실제 구현을 볼 수 있는 코드 자료

### Progressive Rednering Frameworkds Sample - GoogleChromeLabs

1. https://github.com/GoogleChromeLabs/progressive-rendering-frameworks-samples?tab=Apache-2.0-1-ov-file
