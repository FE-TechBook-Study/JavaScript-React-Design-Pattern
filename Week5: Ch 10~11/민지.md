# 민지

# 모듈형 자바스크립트 디자인 패턴

- 모듈형
  - 서로 의존성이 낮은 기능들이 모듈로써 저장된 형태
  - 이러한 느슨한 결합은 의존성을 제거하여 애플리케이션의 유지보수를 용이하게 만든다.

## 10.1 스크립트 로더에 대한 참고사항

- 스크립트 로더
  - 모듈형 자바스크립트를 구현하기 위한 핵심적인 도구
  - 호환 가능한 스크립트 로더를 사용해야만 모듈형 자바스크립트를 구현할 수 있다.

## 10.2 AMD

- AMD(Asynchronous Module Definition)
  - 모듈과 의존성 모두를 비동기적으로 로드할 수 있도록 설계된 모듈 정의 방식
  - 개발자들이 활용할 수 있는 모듈형 자바스크립트 솔루션을 제공하는 것이 주요 목표
  - 비동기적이면서도 높은 유연성을 가지고 있어, 개발 과정에서 흔히 발생하는 코드와 모듈 간 긴밀한 결합을 줄여주는 장점을 가지고 있다.

### 10.2.1 모듈 알아보기

- define 메서드
  - 모듈 정의
  ```jsx
  define(
  	module_id, // 생략할 경우 익명 모듈
  	[dependencies],
  	definition function{} // 모듈이나 객체를 인스턴스화 하는 함수
  )
  ```
  - 익명 모듈은 코드의 재사용성이 높기 때문에 코드 내용이나 모듈 ID를 변경하지 않고도 다른 영역으로 손쉽게 이동할 수 있다. (module_id : 폴더 경로의 개념)
  - dependencies 인자 - 우리가 정의하고 있는 모듈에서 필요로 하는 의존성 배열
  - 세번째 인자 - 모듈을 초기화하기 위해 실행되는 함수
- require 메서드

  - 의존성 로딩 처리
  - 최상위 자바스크립트 파일이나 모듈 내에서 의존성을 동적으로 가져오고자 할 때 사용

- 어째서 AMD가 모듈형 자바스크립트 작성에 더 좋을까?
  - 유연한 모듈 정의 방식에 대한 명확한 제안을 제공한다.
  - 기존에 많이 사용되고 있는 전역 네임스페이스나 <script> 태그 방식에 비해 훨씬 더 구조화되어 있다. 독립적인 모듈과 의존성을 명확하게 선언할 수 있다.
  - 모듈 정의가 독립적으로 이루어지기 때문에 전역 네임스페이스의 오염을 방지할 수 있다.
  - 대부분의 AMD로더는 빌드 과정 없이 브라우저에서 모듈을 로딩하는 것을 지원한다.
  - 여러 모듈을 하나의 파일로 가져오기 위한 전송 방식을 제공한다.
  - 스크립트의 지연 로딩을 지원한다.

## 10.3 CommonJS

- CommonJS
  - 서버 사이드에서 모듈을 선언하는 간단한 API를 지정하는 모듈 제안
  - AMD와는 달리 I/O, 파일 시스템, 프로미스 등 더욱 광범위한 부분을 다룬다.

### 10.3.1 CommonJS 시작하기

- CommonJS 모듈은 재사용 가능한 자바스크립트 코드로써 외부 의존 코드에 공개할 특정 객체를 내보낸다.
- AMD와 달리 모듈을 함수로 감싸는 작업이 필요하지 않다. (define 사용 X)
- exports 변수
  - 다른 모듈에 내보내고자 하는 객체를 담는다.
- require 함수
  - 다른 모듈에서 내보낸 객체를 가져올 때 사용

```jsx
// 외부 라이브러리 가져오기
var lib = require("package/lib");

// 모듈 내부 정의
function foo() {
  lib.log("hello");
}

// 다른 모듈에서 사용할 수 있도록 내보내기
exports.foo = foo;
```

```jsx
var example = require("./example");

// 가져온 모듈에서 제공하는 foo 함수 사용
example.foo();
```

- CommonJS 모듈을 AMD로 변환

```jsx
define(function (require) {
  var lib = require("package/lib");

  function foo() {
    lib.log("hello");
  }

  return {
    foobar: foo,
  };
});
```

### 10.3.3 Node.js 환경에서의 CommonJS

- 최근 ES 모듈 형식이 재사용 가능한 자바스크립트 코드를 모듈화하는 표준으로 잡았지만, 여전히 Node.js 환경에서는 CommonJS가 기본 형식으로 쓰인다.
- Node.js는 다음과 같은 파일들을 CommonJS 모듈로 인식한다.
  - .cjs 확장자를 가진 파일
  - 가장 가까이에 위치한 package.json 파일 안에 type 항목의 값이 commonjs로 되어있는 경우 .js 확장자를 가진 파일
  - 가장 가까이에 위치한 package.json 파일 안에 type 항목이 존재하지 않는 경우 .js 확장자를 가진 파일
  - .mjs .cjs .json .node .js 이외의 확장자를 가진 파일
- require() 함수를 호출하면 항상 CommonJS 모듈 로더가 사용되고, import() 함수를 호출하면 항상 ECMAScript 모듈 로더가 사용된다. 가장 가까이에 위치한 package.json 파일에 설정된 type 값과 관계없이 항상 적용된다.
- React나 Vue같은 프레임워크에서는 Bable같은 트랜스파일러를 사용해 가져오기/내보내기 문법을 구버전 Node.js에서도 작동하는 require()로 변환할 수 있다. ES6 모듈 문법으로 작성된 라이브러리는 Node.js에서 실행할 경우 내부적으로 CommonJS로 트랜스파일 될 것이다.

### 10.3.4 CommonJS는 브라우저 환경에 적합할까?

- ES2015와 AMD 모듈은 생성자나 함수 같은 것을 더 세밀하게 정의할 수 있다. 반면 CommonJS는 오직 객체만을 정의할 수 있기 때문에 생성자를 정의하려는 경우 번거로운 작업이 동반될 수 있다.
- 새로운 Node.js 프로젝트의 경우, ES2015 모듈은 서버에서 CommonJS의 대안으로 사용될 수 있으며, 클라이언트와 서버 사이의 사용 방법에 차이가 없다. 덕분에 브라우저와 서버 양쪽 환경에서 실행될 수 있는 동형 자바스크립트 코드의 구현이 쉬워졌다.

## 10.4 AMD vs CommonJS : 동상이몽

- AMD와 CommonJS는 서로 다른 목표를 가진 유효한 모듈 형식이다.
- AMD는 브라우저 우선 접근 방식을 채택하여 비동기 동작과 간소화된 하위 호환성을 선택한 반면, 파일 I/O에 대한 개념은 없다. 또한 객체, 함수, 생성자, 문자열, JSON 등 다양한 형태의 모듈을 지원하며 브라우저에서 자체적으로 실행된다는 면에서 대단히 유연한 포맷이다.
- CommonJS는 서버 우선 접근 방식을 취하며 동기적 작동, 전역 변수와의 독립성, 미래의 서버 환경을 고려한다. CommonJS는 언래핑된 모듈을 지원하기 때문에 ES2015+ 표준에 조금 더 가깝게 느껴진다.

### 10.4.1 UMD: 플러그인을 위한 AMD 및 CommonJS 호환 모듈

- 브라우저와 서버 환경에서 모두 작동할 수 있는 모듈을 원하는 개발자에게 기존 AMD과 CommonJS의 약점을 해결하는 방안이 필요했다. → UMD
- UMD (Universal Module Definition)
  - 실험 단계의 모듈 포맷
  - 개발 당시에 존재했던 주요 스크립트 로딩 기술의 대부분을 활용하여 클라이언트 및 서버 환경 모두에서 작동하는 모듈
  - AMD와 CommonJS 모두에서 동작할 수 있는 다양한 패턴을 제공하고자 했다.
  - AMD와 CommonJS를 대체하기 위한 것이 아닌 다양한 환경에서 코드가 동작할 수 있도록 돕는 보조 도구

## 10.5 마치며

- 모듈 형식은 단순히 모듈 패턴만 사용하는 것과 비교하여 아래와 같은 장점이 있다.
  - 전역 변수 관리의 필요성 감소
  - 정적/동적 의존성 관리에 대한 향상된 지원
  - 스크립트 로더와의 높은 호환성
  - 서버 환경에서의 모듈 호환성 강화

# 네임스페이스 패턴

- 네임스페이스
  - 코드 단위를 고유한 식별자로 그룹화한 것
  - 하나의 식별자를 여러 네임스페이스에서 참조할 수 있고, 각 식별자는 중첩된 네임스페이스의 계층 구조를 가질 수 있다.

## 11.1 네임스페이스의 기초

- 대규모 자바스크립트 애플리케이션은 거의 대부분 네임스페이스를 활용한다.
- 짧은 코드 조각이 아니라면 네임 스페이스를 올바르게 구현하는 것이 개발을 어렵지 않게 하는데에도 매우 중요한데, 외부에서 가져온 코드가 우리의 코드 동작을 방해하는 것을 막아주기 때문이다.

## 11.2 단일 전역 변수 패턴

- 하나의 전역 변수를 주요 참조 객체로 사용하는 방식

```jsx
const MyUniqueApplication = (() => {
  function myMethod() {
    // code
    return;
  }

  return {
    myMethod,
  };
})();

myUniqueApplication.myMethod();

// 즉시 실행 함수 표현식을 통해 애플리케이션만의 고유한 네임스페이스를 생성하고
// 이를 myUniqueApplication 변수에 담는다.
// IIFE는 함수와 속성을 가진 객체를 반환하고,
// 이 객체에 점 표기법을 사용해서 접근할 수 있다.
```

- 단일 전역 변수 패턴은 특정한 상황에서는 유용할 수 있지만, 다른 개발자가 같은 이름의 전역 변수를 이미 사용하고 있을 가능성이 있다는 것이 가장 큰 문제점이다.

## 11.3 접두사 네임스페이스 패턴

- 단일 전역 변수 패턴에 대한 해결책 중 하나
- 고유한 접두사를 선정한 다음에 모든 메서드, 변수, 객체를 이 접두사 뒤에 붙여서 정의

```jsx
const myApplication_propertyA = {};
const myApplication_propertyB = {};
function myApplication_myMethod() {
  // ...
}
```

- 접두사 네임스페이스 패턴은 전역에서 특정 변수와 이름이 겹칠 가능성을 효과적으로 줄이지만 스스로 고유한 이름을 가진 객체도 같은 효과를 낼 수 있다.
- 이 패턴의 가장 큰 문제점은 애플리케이션이 커짐에 따라 많은 전역 객체가 생성된다는 점이며, 또한 다른 개발자가 같은 접두사를 전역 네임스페이스에서 사용하지 않고 있었을 것이라고 가정하고 있기에, 주의가 필요하다.

## 11.4 객체 리터럴 표기법 패턴

- 일종의 객체로 키와 값으로 이뤄진 집합을 가지며, 각각의 키와 값은 콜론으로 구분된다. 또한 키 자체가 새로운 네임스페이스가 될 수 있다.
- 객체 리터럴 표기법 패턴은 전역 네임스페이스를 오염시키지 않으면서도 코드와 매개변수를 논리적으로 구성하는 데 도움을 준다. 특히 쉽게 읽을 수 있고 깊은 중첩까지 지원하는 구조를 구현할 때 매우 유용하다.
- 동일한 이름의 변수가 있는지 검사하도록 설계되는 경우가 많아 충돌 가능성을 크게 줄여준다.

## 11.5 중첩 네임스페이스 패턴

- 객체 리터럴 패턴을 발전시킨 형태
- 다른 패턴에 비해 충돌 위험이 낮은 편
  - 같은 이름의 네임 스페이스가 존재한다고 하더라도, 하위에 중첩된 네임스페이스까지 정확하게 일치할 가능성이 낮기 때문

```jsx
YAHOO.util.Dom.getElementsByClassName("test");
```

- 새로운 중첩 네임스페이스/속성을 인덱싱된 속성으로 선언할 수도 있다.

```jsx
myApp["routers"] = myApp["routers"] || {};
myApp["models"] = myApp["models"] || {};
myApp["controllers"] = myApp["controllers"] || {};
```

- 두 방법 모두 가독성과 구조성이 뛰어나며 안전한 애플리케이션 개발을 지원한다.
- 하나 주의할 점은 브라우저의 자바스크립트 엔진이 먼저 myApp 객체의 위치를 찾은 후 실제로 사용하고자 하는 함수가 위치한 곳까지 파고들어가야 한다는 것이다. 이러한 과정 덕분에 참조해야할 일이 더 많아질 수 있지만, 단일 객체 네임스페이스 패턴과 중첩 네임스페이스 패턴의 성능 차이는 크지 않다.

## 11.6 즉시 실행 함수 표현식 패턴

- 즉시 실행 함수는 정의 직후 바로 실행되는 이름이 없는 함수이다. 자바스크립트에서 즉시 실행 함수로 정의된 내부의 변수와 함수 모두 외부에서 접근 할 수 없다. → 함수를 호출하는 것만으로도 쉽게 코드의 은닉성을 구현할 수 있다.
- 즉시 실행 함수는 애플리케이션의 로직을 캡슐화하여 전역 네임스페이스로부터 보호하는 데 널리 사용되는 방법이다.

```jsx
// 즉석에서 호출되는 익명 함수 표현식
(() => {
  // code
})();

// 이름이 있는 즉시 실행 함수 표현식
(function foobar() {
  // code
})();
```

## 11.7 네임 스페이스 주입 패턴

- 즉시 실행 함수 패턴의 또 다른 변형
- 함수 내에서 this를 네임스페이스의 프록시로 활용하여 특정 네임스페이에 메서드와 속성을 주입한다.
- 여러 객체나 네임스페이스에 기능적인 동작을 쉽게 적용할 수 있다는 장점이 있다. 또한 이후에 확장될 기본 메서드에 적용할 때 유용하다.
- 네임 스페이스의 단점은 같은 목적을 달성하는 더 쉽고 효율적인 방법이 존재할 수도 있다는 점이다.
- 이러한 유형의 패턴은 여러 모듈이나 네임스페이스에 비슷한 기본 기능들을 할당할 때 유용하다. 하지만 객체/클로저 내에서 명시적으로 기능을 선언할 때 직접 접근하는 것이 불가능한 상황에서만 사용하는 것을 추천한다.

## 11.8 고급 네임스페이프 패턴

- 대규모 애플리케이션을 개발할 때 유용한 고급 패턴과 유틸리티

### 11.8.1 중첩 네임스페이스 자동화 패턴

- 중첩 네임스페이스는 코드에 체계적이고 계층적인 구조를 만들어준다.

```jsx
// application.utilities.drawing.canvas.2d

const application = {
  utilities: {
    drawing: {
      canvas: {
        paint: {
          // ...
        },
      },
    },
  },
};
```

- 위 패턴의 단점은 추가하고자 하는 계층이 늘어날수록 최상위 네임스페이스에 더 많은 하위 객체들이 정의되어야 한다는 점이다.
- 이 문제를 해결하고자 제시한 방법 → 하나의 문자열 인자를 받아서 파싱한 뒤에 필요한 객체를 기반 네임스페이스에 자동으로 추가하는 간편한 방법

```jsx
// 최상위 네임 스페이스에 객체 리터럴 할당
const myApp = {};

function extend(ns, ns_string) {
  const parts = ns_string.split(".");
  let parent = ns;
  let pl;

  pl = parts.length;
}
```

### 11.8.2 의존성 선언 패턴

- 중첩 네임스페이스 패턴을 약간 변형한 형태
- 객체에 대한 로컬 참조가 전체적인 조회 시간을 단축한다는 원칙을 네임스페이스에 적용
- 로컬 변수를 사용하면 전역 변수를 매번 사용하는 것보다 더 빠르다. 또한 후속 작업에서 중첩된 속성이나 하위 네임스페이스에 매번 접근하는 것보다 더 편리하고 성능이 뛰어나다. → 복잡한 애플리케이션에서는 가독성 또한 높일 수 있다.
- 함수나 모듈에서 사용할 로컬 네임스페이스를 함수 영역의 상단에 선언할 것을 권장하며(단일 변수 패턴 사용), 이 방식을 의존성 선언 패턴이라고 한다.
  - 의존성을 찾고 해석하는 시간을 줄일 수 있다.
  - 필요할 때 동적으로 모듈을 네임스페이스에 추가하는 확장 가능한 아키텍처가 가능하다.
- 네임스페이스 간 의존성이 중복되는 경우가 많다면 함수 단위로 네임스페이스를 지역화 하는 것은 피하는것이 좋다.
