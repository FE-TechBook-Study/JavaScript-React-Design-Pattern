# 8장 자바스크립트 MV\* 패턴

## 8.1 MVC 패턴

애플리케이션의 구조를 개선하기 위해 관심사의 분리를 활용하는 아키텍처 디자인 패턴이다.

비즈니스 데이터(모델)과 UI(뷰)를 분리하고, 세 번째 구성 요소(컨트롤러)가 로직과 사용자 입력을 관리하는 구조이다.

## 8.2 자바스크립트의 MVC

### 8.2.1 모델

애플리케이션의 데이터를 관리하는 역할을 한다.

모델이 변경될 때(예: 업데이트) 관찰자(예: 뷰)에게 변경사항을 알린다.

이렇게 함으로써 관찰자가 변경된 내용에 알맞게 능동적으로 대응할 수 있게끔 한다.

한가지 모델을 여러 뷰가 관찰할 수도 있다.

예를 들어, 위치 정보(경도와 위도), 사진에 등장하는 친구들(식별자 목록), 태그 목록 등의 메타데이터가 포함된 사진 모델의 경우, 개발자는 이런 세 가지 측면 각각을 표시하는 뷰를 제공하기로 결정할 수 있다.

### 8.2.2 뷰

뷰는 모델에 대한 시각적인 표현으로, 현재 상태의 특정 부분만 보여준다.

자바스크립트의 뷰는 여러 DOM 요소의 집합을 생성하고 정리하는 역할을 한다.

일반적으로 뷰는 모델을 관찰하고, 모델에 변화가 생기면 알림을 받는다.

이를 통해, 뷰는 스스로를 업데이트할 수 있다.

뷰는 프레젠테이션 계층이기 때문에 편집과 업데이트 기능을 유저 친화적으로 제공한다.

모델을 실제로 업데이트하는 작업은 컨트롤러가 담당한다.

### 8.2.3 템플릿

템플릿은 뷰와 연관된다.

문자열의 연결을 통해 메모리에 큰 HTML 마크업 블록을 수동으로 새엇ㅇ하는 것은 성능적으로 나쁜 작업으로 오랫동안 간주되어 왔다.

최신 자바스크립트 템플릿 솔루션은 ES6의 강력한 기능인 태그 템플릿 리터럴의 사용으로 방향을 전환했다.

별도의 템플릿 라이브러리의 필요성을 제거하고, 동적인 HTML 콘텐츠를 생성하는 간결하고 유지보수가 용이한 방법을 제공한다.

템플릿 자체가 뷰는 아니다.

뷰는 모델을 관찰하고 시각적 표현을 최신 상태로 유지하는 객체이다.

프레임워크가 템플릿 명세에 따라 뷰를 생성할 수 있도록, 템플릿은 뷰 객체의 일부 또는 전체를 선언적으로 지정하는 방법이 될 수 있다.

요약하자면, 뷰는 애플리케이션 데이터를 시각적으로 표현하고, 템플릿은 뷰를 생성하기 위해 사용될 수 있다.

### 8.2.4 컨트롤러

모델과 뷰 사이의 중재자 역할을 하며, 일반적으로 사용자가 뷰를 조작할 때 모델을 업데이트하는 역할을 한다.

컨트롤러는 애플리케이션 내에서 모델과 뷰 간의 로직 그리고 연동을 관리한다.

## 8.3 MVC를 사용하는 이유는?

- 전반적인 유지보수의 단순화:
  - 애플리케이션을 업데이트해야 할 때, 변경사항이 데이터 중심인지 (모델과 컨트롤러의 변경) 아니면 단순히 시각적인 변경인지 (뷰의 변경) 명확하게 구분할 수 있다.
- 모델과 뷰의 분리:
  - 비즈니스 로직에 대한 단위 테스트의 작성이 훨씬 간편해진다.
- 애플리케이션 전반에서 하위 수준의 모델과 컨트롤러 코드 중복이 제거된다.
- 애플리케이션 규모와 역할의 분리 정도에 따라, 모듈화를 통해 코어 로직을 담당하는 개발자와 UI 작업을 담당하는 개발자가 동시에 작업할 수 있다.

## 8.6 MVP 패턴

프레젠테이션 로직의 개선에 초점을 맞춘 MVC 디자인 패턴의 파생이다.

### 8.6.1 모델, 뷰, 프레젠터

P는 프레젠터를 의미한다.

프레젠터는 뷰에 대한 UI 비즈니스 로직을 담당하는 구성 요소이다.

MVC와 달리, 뷰에서의 이벤트 호출은 프레젠터로 위임된다.

프레젠터는 뷰와 분리되어 있으며, 인터페이스를 통해 뷰와 통신한다.

이 방식은 단위 테스트에서 뷰를 모킹할 수 있는 등의 많은 장점을 제공한다.

MVP의 P는 모델을 관찰하고 모델이 변경될 때 뷰를 업데이트한다.

P는 모델과 뷰를 효과적으로 연결하는데, 이건 원래 MVC에서 컨트롤러가 담당하던 역할이다.

뷰의 요청에 따라, 프레젠터는 사용자 요청과 관련된 작업을 수행하고 데이터를 뷰로 다시 전달한다.

이를 위해 프레젠터는 데이터를 가져오고, 조작하고, 이 데이터가 어떻게 뷰에 표시되어야 하는지 결정한다.

모델이 이벤트를 발생시킬 수도 있지만, 이벤트를 구독하여 뷰를 업데이트할 수 있도록 하는 것이 프레젠터의 역할이다.

### 8.6.2 MVP vs MVC

MVP는 일반적으로 프레젠테이션 로직을 최대한 재사용해야 하는 엔터프라이즈 수준의 애플리케이션에서 사용된다.

뷰가 매우 복잡하고 사용자와의 상호작용이 많은 애플리케이션에서는 MVC가 적합하지 않을 수 있다.

이런 문제를 MVC로 해결하려면 여러 컨트롤러에 크게 의존해야 할 수 있기 때문이다.

MVP에서는 이 모든 복잡한 로직을 프레젠터 안에 캡슐화할 수 있어 유지보수가 훨씬 간단해진다.

## 8.7 MVVM 패턴

MVC와 MVP를 기반으로 하는 아키텍처 패턴으로, 애플리케이션의 UI 개발 부분과 비즈니스 로직, 동작 부분을 명확하게 분리한다.

많은 MVVM의 구현 방식은 선언적 데이터 바인딩을 활용하여 뷰에 대한 작업을 다른 계층과 분리할 수 있도록 한다.

### 8.7.2 모델

우리 애플리케이션이 사용할 도메인 관련 데이터나 정보를 제공한다.

대표적인 예로는 사용자 계정(이름, 아바타, 이메일) 또는 음악 트랙(제목, 연도, 앨범) 등이 있다.

모델은 보통 정보를 담고 있지, 동작을 다루지 않는다.

모델은 정보 형식을 지정하지 않고, 데이터가 브라우저에 어떻게 표현될지에 영향을 미치지 않는다.

이러한 역할을 모델의 책임이 아니기 때문이다.

대신에 데이터 형식 지정은 뷰가 담당하고, 동작은 모델과 상호작용하는 또 다른 계층인 뷰모델에서 캡슐화하여 처리해야 하는 비즈니스 로직으로 간주된다.

### 8.7.3 뷰

뷰는 애플리케이션에서 사용자가 상호작용하는 유일한 부분이고, 뷰모델의 상태를 표현하는 상호작용이 가능한 UI이다.

이러한 점에서 뷰는 수동적이라기보다는 능동적으로 볼 수 있다.

수동적 뷰는 단순히 화면을 출력할 뿐 사용자 입력을 받아들이지 않는다.

이러한 뷰는 애플리케이션의 모델에 대한 구체적인 정보를 갖고 있지 않을 수 있으며, 프레젠터에 의해 조작될 수 있다.

반면, 능동적 뷰는 데이터 바인딩, 이벤트, 동작들을 포함하고 있어 뷰모델에 대한 이해를 필요로 한다.

비록 이러한 동작들이 속성에 연결될 수는 있지만, 뷰모델로부터 발생한 이벤트를 처리하는 책임은 여전히 뷰가 갖고 있다.

중요한 점은 뷰는 상태를 관리할 책임이 없다는 것이다. 뷰는 뷰모델의 정보 또는 상태를 항상 동기화된 상태로 유지하기 때문이다.

### 8.7.4 뷰모델

데이터 변환기의 역할을 하는 특수한 컨트롤러로 볼 수 있다.

모델의 정보를 뷰가 사용할 수 있는 형태로 변환하고, 뷰에서 발생한 명령(사용자의 조작이나 이벤트)을 모델로 전달한다.

예를 들어, UNIX 포맷의 날짜 속성 (예: 133832407)을 가지고 있는 모델이 있다고 가정해보자.

모델이 상요자가 보게 될 날짜 표시 방식 (예: 04/07/2012 @ 5:00 pm)으로 형식을 바꾸어 저장하는게 아니라, 원시 포맷 그대로 유지한다.

뷰에는 포맷된 날짜가 표시되고, 뷰모델은 뷰와 모델 둘 사이를 잇는 다리 역할을 수행한다.

이러한 관점에서, 뷰모델은 뷰라기보다는 모델에 더 가깝다고 볼 수 있다.

그러나 동시에 뷰의 디스플레이 로직 대부분을 처리한다.

뷰모델은 뷰의 상태를 유지하고, 뷰에서 발생한 동작에 기반해 모델을 업데이트하여, 뷰에 이벤트를 발생시키는 등의 기능을 수행하기 위한 메서드도 제공한다.

정리하자면, 뷰모델은 UI 계층의 뒤에 위치한다. 뷰가 필요로 하는 데이터를 (모델로부터 가져와) 제공하며, 데이터와 사용자의 동작 모두를 뷰가 참조하는 출처의 역할을 할 수 있다.

## 8.8 장단점

### 8.8.1 장점

- MVVM은 UI와 이를 구동하게 해주는 요소를 동시에 개발할 수 있도록 한다.
- MVVM은 뷰를 추상화함으로써 뷰의 뒤에 작성되는 비즈니스 로직(또는 연결 코드)의 양을 줄여준다.
- 뷰모델은 이벤트 중심 코드에 비해 단위 테스트가 더 쉽다.
- 뷰모델은 (뷰보다는 모델에 가까우므로) UI 자동화나 상호작용에 대한 고려 없이도 테스트가 가능하다.

### 8.8.1 단점

- 단순한 UI의 경우, MVVM은 과도한 구현이 될 수 있다.
- 데이터 바인딩은 선언적이고 사용하기 편리할 수 있지만, 단순히 중단점을 설정하는 명령형 코드에 비해 디버깅이 더 어려울 수 있다.
- 복잡한 애플리케이션에서는 데이터 바인딩이 상당한 관리 부담을 만들어 낼 수있다. 또한 바인딩 코드가 바인딩 대상 객체보다 더 무거운 상황도 피하고 싶다.
- 대규모 애플리케이션에서는 필요한 일반화를 제공하기 위해 뷰모델을 미리 설계하는 것이 어려울 수 있다.

## 8.9 MVC vs MVP vs MVVM

MVP와 MVVM은 모두 MVC에서 파생된 패턴이다.

MVC와 이 파생 패턴들 사이의 핵심 차이점은 각 계층이 다른 계층에 대해 갖는 의존성과, 서로 얼마나 강하게 연결되어 있는지에 있다.

## 8.10 MV\*패턴과 리액트

리액트는 MVC 프레임워크가 아니다.

리액트는 UI 구축을 위한 자바스크립트 라이브러리이며, 주로 SPA 개발에 사용된다.

리액트는 백엔드에서 전통적으로 구현되고, 사용되는 MVC 패턴과 잘 맞지 않기 때문에 MVC로 분류되지 않는다.

리액트는 뷰 계층을 원하는대로 구성하게 해주는 렌더링 라이브러리이다.

기존 MVC와 같이 중앙 제어 역할을 하는 컨트롤러, 혹은 라우터 기능이 포함되어 있지 않는다.

리액트는 선언형 프로그래밍 방식을 따른다.

즉, 개발자는 애플리케이션이 원하는 상태를 기술하고, 리액트는 그 상태를 기반으로 적절한 뷰를 렌더링한다.

리액트를 MVC 패턴에서 사용하지 않는 이유는 리액트엣허는 서버가 브라우저에 ‘뷰’를 직접 제공하지 않고, ‘데이터’를 제공하기 때문이다.

리액트는 이 데이터를 브라우저에서 구문 분석하여 실제 뷰를 생성한다.

이러한 관점에서, 리액트를 MVC 패턴의 뷰라고 할 수는 있지만, 전통적인 의미에서의 MVC 프레임워크는 아니다.

최근에는 많은 컴포넌트 로직이 Hooks로 구성됨에 따라, 컴포넌트를 뷰로, Hooks를 컨트롤러로 볼 수 있다.

‘모델 → 비동기 데이터, 뷰 → 컴포넌트, 컨트롤러 → hook’ 으로 이해하는 것도 도움이 될 수 있지만, 단순히 개념 파악을 위한 비유일 뿐 엄밀한 뜻은 아니다.

# 9 비동기 프로그래밍 패턴

비동기 자바스크립트 프로그래밍은 브라우저가 이벤트에 응답하여 다른 코드를 실행하는 동안, 백그라운드에서 오랜 시간이 걸리는 작업을 수행하게 해준다.

프로미스(Promise), Async/await 등의 자바스크립트 개념은 메인 스레드를 차단하지 않으면서도 코드를 깔끔하고 읽기 쉽게 만들어준다.

## 9.1 비동기 프로그래밍

자바스크립트에서 동기 코드는 블로킹 방식으로 실행된다.

이는 코드가 순서대로 한 번에 한 문장씩 실행됨을 의미한다.

코드에서 다음 줄의 문장은 현재 문장의 실행이 완료된 후에만 실행될 수 있다.

동기 함수를 호출하면, 호출자에게 결과를 반환하기 전에 함수 내부의 코드가 처음부터 끝까지 한 줄씩 실행될 것이다.

반면에 비동기 코드는 논블로킹 방식으로 실행된다.

즉, 자바스크립트 엔진은 현재 실행중인 코드가 다른 작업을 기다리는 동안 백그라운드에서 해당 비동기 코드를 실행할 수 있다.

비동기 함수를 호출하면, 함수 내부의 코드가 백그라운드에서 실행되며 호출자에게 즉시 결과가 반환된다.

비동기(async, await), 프로미스(promise)와 같은 자바스크립트 언어의 기능은 비동기 코드를 더 쉽게 작성할 수 있게 해준다.

이 기능을 활용하면 비동기 코드를 마치 동기 코드처럼 작동하도록 작성할 수 있어 코드의 가독성과 이해도가 높아진다.

## 9.2 배경

자바스크립트에서 콜백 함수는 다른 함수에 인수로서 전달되어, 비동기 작업이 완료된 후 실행된다.

콜백 함수는 주로 네트워크 요청이나 사용자 입력과 같은 비동기 작업의 결과를 처리하기 위해 사용되었다.

콜백을 사용할 때의 주요 단점 중 하나는 ‘콜백 지옥’으로 불리는 상황을 초래할 수 있다는 것이다.

콜백 지옥은 중첩된 콜백 구조로 인해 코드의 가독성과 유지보수성이 크게 저하되는 상황을 뜻한다.

## 9.3 프로미스 패턴

프로미스는 자바스크립트에서 비동기 작업을 처리하는 최신 방법이다.

프로미스는 비동기 작업의 결과를 나타내는 객체로, 대기(Pending), 완료(fulfilled), 거부(rejected)의 세 가지 상태를 가질 수 있다.

작업이 성공적으로 완료되었거나 거부되었을 때 결과를 제공하는 일종의 계약서 같은 존재이다.

프로미스는 Promise 생성자를 사용하여 만들 수 있으며, 이 생성자는 함수를 인수로 받는다.

또 다시 이 함수는 resolve와 reject 두 개의 인수를 전달받는다.

resolve 함수는 비동기 작업이 성공적으로 완료되었을 때 호출되고, reject 함수는 작업이 실패했을 때 호출된다.

## 9.4 async/await 패턴

비동기 코드를 마치 동기 코드처럼 작성할 수 있게 해주는 자바스크립트의 기능이다.

프로미스를 기반으로 구축되었으며, 비동기코드 작업을 보다 쉽고 간결하게 만들어준다.
