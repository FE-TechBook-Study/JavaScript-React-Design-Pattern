
## 1장 디자인 패턴 소개

🧐 디자인 패턴이란 무엇일까?

### 1.1 디자인 패턴의 역사

- 크리스토퍼 알렉산더(건축가) - 특정 디자인 구조를 반복해서 사용하면 최적의 효과를 얻을 수 있다.
- 소프트웨어 엔지니어 - 디자인 패턴 문서의 첫 장에 알렉산더의 원칙을 담기 시작
- 디자인 패턴에 대한 개념은 아직 체계화된 형태를 잡지 못했지만, 개발 업계의 초창기부터 사용되어 왔다는 점이 중요

### 1.2 패턴이란 무엇인가

- 패턴 : **소프트웨어 설계에서 반복되는 문제와 주제에 적용할 수 있는 재사용 가능한 템플릿**
- 디자인 패턴이 개발자들에게 유용한 이유
    - 오랜 시간 동안 **검증된** 효과적인 접근 방식이다.
        - 앞서간 개발자들의 경험과 통찰의 산물
    - 쉽게 재사용할 수 있다.
    - 정해진 구조와 공통 표현을 사용하여 알아보기 쉽다.

### 1.3 디자인 패턴의 일상 활용 사례

- 공급자 패턴
    - (문제점)컴포넌트의 계층 구조가 깊어지고, 중첩이 많아지면 프롭 드릴링을 초래하게 되며 해당 데이터를 사용하는 모든 하위 컴포넌트에 프로퍼티 설정과 전달이 반복되어 유지보수가 어려운 코드가 만들어지게 된다.
    - (해결 방안) 공급자 패턴 사용
        - Context API를 사용하면 컨텍스트 공급자를 통해 상태나 데이터를 여러 컴포넌트로 한번에 전달할 수 있다.
        - 공유되는 데이터가 필요한 하위 컴포넌트눈 컨텍스트 소비자나 useContext Hook을 사용하여 쉽게 공급자의 데이터에 접근 할 수 있다.


## 2장 패턴성 검증, 프로토 패턴 그리고 세가지 법칙

🧐 프로토 패턴이란 무엇일까?
🧐 패턴의 검증 방법은 어떻게 이루어질까?

### 2.1 프로토 패턴이란?

- 패턴의 기준을 갖춘것처럼 보여도 철저한 조사와 검증을 거치기전까지는 패턴으로 간주해서는 안된다.
- 패턴을 실제로 적용했을 때 구조를 시각적으로 표현할 수 있어야한다.

### 2.2 패턴성 검증

- 프로토 패턴 : 패턴성 검증을 모두 통과하지 않은 미숙한 패턴
- 패턴성 검증 항목 (좋은 패턴이라고 간주하는 사항들)
    - 특정 문제를 해결할 수 있다.
        - 단순 원리나 방법만을 담고있는 것이 아닌 특정 문제를 해결할 수 있어야한다.
    - 명쾌한 해결책이 없다.
        - 해결책을 간접적으로 제공
    - 확실한 기능만을 말한다.
    - 관계를 설명한다.
        - 코드와의 관계를 나타내는 심층 구조와 메커니즘을 서술해야 한다.

### 2.3 세가지 법칙

- 좋은 패턴이 되기 위해 반복되는 문제에서 지속적으로 사용되어야한다.
- 반복성을 입증하기 위한 세가지 법칙
    - 목적 적합성
        - 좋은 패턴은 어떻게 판단하는지?
    - 유용성
        - 좋은 패턴이라고 할 수 있는 이유가 무엇인지?
    - 적용 가능성
        - 넓은 적용 범위를 가지고 있는지?


## 3장 패턴 구조화 및 작성

🧐 패턴을 어떻게 구조화하고 작성할까?
🧐 패턴을 작성하거나 도입할 때 고려해야하는 점은 무엇일까?

### 3.1 디자인 패턴의 구조

- 패턴 작성자 본인이 패턴의 사용 목적을 알 수 없다면 성공적인 패턴이라고 할 수 없다.
- 패턴 사용자 또한 관련된 배경지식을 가지고 있지 않다면 패턴을 제대로 이해하지 못한 채 사용하게 된다.
- 패턴 작성자는 다음의 관계성을 생각해 규칙의 형태로 패턴을 제시한다.
    - 컨텍스트(Context) : 패턴이 적용되는 상황
    - 집중 목표(System of Forces) : 패턴을 적용할 때 고려해야 하는 목표
    - 구성(Configuration) : 제시된 상황과 고려해야 하는 점들을 해결하는 구성
- 디자인 패턴의 구성 요소
    - **이름 - 패턴의 목적을 드러내야함**
    - **설명 - 패턴이 무엇을 해결할 수 있는지에 대한 간단한 설명**
    - **컨텍스트 개요 - 패턴이 사용자의 요구에 부합하는지에 대한 설명**
    - **문제 제시 - 패턴을 만든 의도를 알 수 있도록 문제를 제시**
    - **해결 방법 - 이해하기 쉬운 단계와 개념을 통해 문제가 어떻게 해결되는지에 대한 설명**
    - 설계 내용 - 패턴의 설계와 사용자가 어떻게 사용할 수 있는지에 대한 설명
    - 구현 방법 - 패턴을 구현하는 방법에 대한 지치
    - 시각적 설명 - 다이어그램처럼 패턴을 나타내는 시각적 설명
    - 예제 - 패턴을 구현한 예시
    - 필수 연계 - 해당 패턴과 함께 사용하면 좋은 패턴에 대한 내용
    - 관계성 - 다른 패턴과의 관계 및 유사점에 대한 내용
    - 알려진 용도 - 업계에서 이미 쓰이던 패턴인지에 대한 설명
    - 토론 - 해당 패턴의 이점에 대한 사람들의 의견

### 3.2 모범 패턴

- 디자인 패턴의 구조와 만들어진 목적을 이해하면 해당 패턴이 필요한 이유에 대해 더 깊게 이해할 수 있다.
- 좋은 패턴은 **사용자에게 충분한 자료를 제공**해야하며 **왜 이 패턴이 필요한지에 대한 근거를 제공**해야한다.
- 패턴에 대한 개념을 알고있다고 해서 패턴을 쉽게 알아볼 수는 없다.
    - 어떠한 상호작용이나 정해진 규칙이 보이지 않으면 패턴이 아니다.
- 패턴은 초기 비용이 많이 들 수도 있지만, 그 투자로 얻을 수 있는 가치가 크다.
    - 팀의 모든 개발자가 동일한 지식을 공유하고 작업할 수 있기 때문
- 패턴을 사용하고 싶다면 처음부터 직접 만들기보다는 이미 존재하는 검증된 패턴을 찾아보는 게 더 좋은 방법

### 3.3 패턴 작성하기

- 디자인 패턴을 직접 개발하려고 한다면 이미 잘 만들어진 다른 패턴을 참고하는 것이 좋다.
    - 올바른 구성을 가진 패턴의 상호작용과 문맥에 대해 조사하면 패턴의 구조와 의미에 대해 알 수 있다.
    - 예) 기존에 존재하던 모듈 패턴을 참고하여 노출 모듈 패턴에서 획기적인 개선을 이루어 냄
- 신규 디자인 패턴, 기존 디자인 패턴 적용 전 참고하기 좋은 항목
    - 얼마나 실용적인가?
        - 추측성 해결책이 아니라 반복되는 문제에 대한 해결책 제시
    - 모범 사례를 염두에 두어라
    - 사용자에게 솔직해라
    - 독창성은 패턴 설계의 핵심이 아니다
        - 패턴의 최초 발견자가 될 필요도 없고 다른 패턴과 조금 겹치는 부분이 있어도 상관없음
    - 훌륭한 예시가 있는가?
- 패턴을 작성한다는 것은 범용성, 구체성, 유용성 사이에서 세심한 균형을 유지한다는 것을 뜻한다.


## 4장 안티 패턴

🧐 안티 패턴이란 무엇일까?
🧐 안티 패턴을 이해하고 판별하는 것이 왜 필요할까?

### 4.1 안티 패턴이란?

- 안티 패턴이란 잘못된 패턴을 뜻한다.
    - 겉으로만 해결책처럼 생긴 패턴
    - 문제 상황에 대한 잘못된 해결책
    - 문제 상황에서 벗어나 올바른 해결책에 이르는 방법
- 애플리케이션의 품질은 팀의 기술 레벨과 투자한 시간에 따라 좋아질수도, 나빠질수도 있다. 좋고 나쁨은 상황에 따라 결정되며, 완벽한 설계도 잘못된 상황에서 사용된다면 안티 패턴이 될 수 있다.
    - → 절대적인 안티패턴은 없다?
- 안티 패턴은 반면교사로 활용하기 위해 문서화하여 기록해야 하는 나쁜 디자인

### 4.2 자바스크립트 안티 패턴

- 신속한 구현을 위해 선택한 임시 방편이 영구적으로 이어지는 경향이 있으며, 결국 기술 부채가 되어 안티 패턴이 되곤한다.
- 자바스크립트의 안티 패턴 예시
    - 전역 컨테스트에서 수많은 변수를 정의하여 전역 네임스페이스를 오염시키기
    - setTimeout이나 setInterval에 함수가 아닌 문자열을 전달해서 내부적으로 eval()실행되게 하기
    - Object 클래스의 프로토타입을 수정하기 (특히 안좋음)
    - 자바스크립트를 인라인으로 사용하여 유연성을 떨어뜨리기
    - document.createElement 대신 document.write 사용하기 - 책 참고
- 안티 패턴을 알아볼 수 있게 된다면 코드를 리팩토링해 제품의 품질을 단번에 끌어올릴 수 있다.


## 5장 최신 자바스크립트 문법과 기능

🧐 모듈과 클래스에 대해 알아보자

### 5.1 애플리케이션 분리의 중요성

- 모듈형 자바스크립트는 애플리케이션을 모듈이라는 단위로 쪼갤 수 있다.
- 애플리케이션은 여러 개의 중첩된 모듈로 구성될 수 있다.
- 모듈형 - 잘게 분리된 모듈로 구성되어있음
    - 이렇게 느슨한 결합은 의존성을 낮추어 애플리케이션의 유지보수를 용이하게 한다.
    - 어느 한 부분의 변경이 다른 부분에 어떤 영향을 미칠 수 있을 지 쉽게 확인이 가능

### 5.2 모듈 가져오기와 내보내기

- 모듈을 사용하면
    - 각 기능에 맞는 독립적인 단위로 코드를 분리할 수 있다.
    - 코드의 재사용성을 높여 다른 애플리케이션에도 같은 기능을 적용할 수 있게 한다.
- 모듈형 언어가 되기 위해서는 의존성을 가진 모듈을 가져오고 내보낼 수 있어야한다.
    - 자바스크립트 모듈은 import를 통해 가져오고 export를 통해 내보낸다.
- `.mjs`
    - 모듈 파일과 기존 스크립트를 구분하기 위해 쓰이는 모듈 전용 확장자
    - 런타임 및 빌드 도구에 모듈임을 알릴 수 있음
- 여러 함수, 상수, 변수를 가지고 있는 경우 파일 끝부분에서 내보내고 싶은 모듈을 객체로 정리하여 하나의 export문으로 내보낼 수 있다.

```
const baker = {
	// baker 관련 함수들
}

const pastryChef = {
	// pastry chef 관련 함수들
}

const assistant = {
	// assistant 관련 함수들
}

export {baker, pastryChef, assistant}
```

- 사용할 모듈만 가져올 수 있다.

```
import {baker, assistant} from "/module/staff.mjs"
```

- script 태그에서 type에 모듈을 명시하여 브라우저에게 알릴 수 있다.
- nomodule
    - 브라우저에 모듈이 아님을 알려주는 역할
    - 모듈 문법을 사용하지 않는 대체 스크립트에 유용하며 모듈을 지원하지 않는 브라우저에서도 기능이 제대로 작동할 수 있도록 한다.

```
<script type="module" src="main.mjs" />
<script nomodule src="fallback.js" />
```

### 5.3 모듈 객체

- 모듈을 객체로 가져오게 될 경우 객체 하나만으로 여러 곳에 사용할 수 있다.

```
import * as Staff from "/modules/staff.mjs"

Staff.baker.bake("cupcake")
Staff.assistant.make("cream")
```

### 5.4 외부 소스로부터 가져오는 모듈

- ES2015부터는 외부 소스에서 가져오는 원격 모듈을 쉽게 가져올 수 있다.

```
import {cakeFactory} from "example.com/modules/cakeFactory.mjs" 
```

### 5.5 정적으로 모듈 가져오기

- 5-2 ~ 5-4 예시는 모두 정적 가져오기이다.
- 정적 가져오기
    - 메인 코드를 실행하기 전 먼저 모듈을 다운로드한 후 실행해야 하기 때문에 성능에 문제가 생길 수 있다.

### 5.6 동적으로 모듈 가져오기

- 지연 로딩 모듈을 사용하면 필요한 시점에 로드할 수 있다.
    - 링크나 버튼을 클릭할 때 로드하게 만들어 **초기 로딩 시간을 줄일 수 있다.** → 동적 가져오기가 생긴 이유
- 동적 가져오기를 사용하면 모듈이 사용될때만 다운로드되고 실행된다.
- 자주 사용되는 예로는 사용자 상호작용에 반응하거나 화면에 보이면 실행하기 등이 있다.

```
form.addEventListener("submit", e => {
	e.preventDefault()
	import("/modules/cakeFactory.js")
		.then((module) => {
			// 가져온 모듈 사용
			module.oven.makeCupcake("sprinkles")
		})
})

// await과 함께 사용 가능
let module = await import("/modules/cakeFactory.js")
```

### 5.7 서버에서 모듈 사용하기

- Node 15.3.0 버전 이상에서는 자바스크립트 모듈을 지원한다.
- type이 module이라면 .mjs와 .js로 끝나는 파일을 자바스크립트 모듈로 취급한다.

### 5.8 모듈을 사용하면 생기는 이점

- 한 번만 실행된다.
- 자동으로 지연 로드된다.
- 유지보수와 재사용이 쉽다.
- 네임스페이스를 제공한다.
- 사용하지 않는 코드를 제거한다.
    - 웹팩이나 롤업같은 번들러를 사용해 사용하지 않는 모듈을 자동으로 제거할 수 있다.
    - 번들에 추가하기 전 사용하지 않는 코드를 제거하는 것을 트리쉐이킹이라고 한다.

### 5.9 생성자, 게터, 세터를 가진 클래스

```
class Cake {
	constructor(name, toppings, price, cakeSize) {
		this.name = name;
		this.toppings = toppins;
		this.price = price;
		this.cakeSize = cakeSize;
	}

	addTopping(topping) {
		this.toppings.push(topping)
	}
	
	get allToppings(){
		return this.toppings;
	}
	
	get qualifiesForDiscount(){
		return this.price > 5;
	}
	
	set size(size){
		if(size < 0) {
			throw new Error("error !")
		}
		this.cakeSize = size;
	}
}

let cake = new Cake("mint", ["chocolate chips"], 5, "large")
```

- extends 키워드를 통해 클래스를 상속받을 수 있다.

```

class BirthdayCake extends Cake {
	surprise(){
		console.log('HBD !')
	}
}

let birthdayCake = new BirthdayCake("mint", ["chocalate chips"], 5, "large")
birthdayCake.surprise()
```

- super 키워드를 통해 부모 클래스의 생성자를 실행할 수 있다.

```
class Cookie {
	constructor(flavor) {
		this.flavor = flavor;
	}
	
	showTitle(){
		console.log(`This cookie is ${this.flavor}`)
	}
}

class FavoriteCookie extends Cookie {
	showTitle(){
		super.showTitle()
		console.log(`My Favorite cookie is ${this.flavor}`)
	}
}

lef myCookie = new FavoriteCookie(`chocolate`)
myCookie.showTitle() 
// This cookie is chocolate
// My Favorite cookie is chocolate
```

- #(해시)를 붙여 클래스 내부 멤버를 비공개로 정의할 수 있다.
- 비공개 멤버는 선언된 클래스 내부에서만 사용 가능하다.

```
class CookieWithPrivateField {
 #privateField;
}

clsdd CookieWithPrivateMethod {
	#privateMethod(){
		return 'I am private.'
	}
}
```

- static 키워드를 통해 정적 메서드와 프로퍼티를 정의할 수 있다.
- 정적 멤버는 클래스를 초기화하지 않고도 사용 가능하다.
- 주로 어떠한 설정이나 캐시 데이터를 보관하기 위해 사용된다.

```
class Cookie {
	constructor(flavor) {
		this.flavor = flavor;
	}
	static brandName = "Minji Cookie"
	static discountPercent = 50
}

console.log(Cookie.brandName) // Minji Cookie
```
