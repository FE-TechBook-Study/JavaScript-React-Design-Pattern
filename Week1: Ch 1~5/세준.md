# 1장 디자인 패턴 소개

## 디자인 패턴 장점

1. 검증되었다.
2. 쉽게 재사용할 수 있다.
3. 공통 표현을 사용하여 알아보기 쉽다.
4. 개발 과정에서 사소한 실수로 인한 큰 문제를 방지한다.
5. 특정 문제에 국한되지 않은 종합적인 해결책을 제시한다.
6. 반복을 피함으로써 코드의 반복을 줄인다.
7. 공통된 어휘를 사용하여 의사소통이 원할해진다.

## 디자인 패턴 활용 사례

리액트에서 대표적으로는 공급자 패턴이 있다.

- 프롭 드릴링 방지

<br/>

# 2장 패턴성 검증, 프로토 패턴, 그리고 세 가지 법칙

## 프로토 패턴이란?

‘패턴성’ 검증을 모두 통과하지 않은 미숙한 패턴을 말한다.

간단한 설명을 덧붙여 공개하는 경우도 있는데 설명이나 코드 조각들을 `패틀릿`이라고 한다.

## 좋은 패턴의 세 가지 법칙

1. 목적 적합성
2. 유용성
3. 적용 가능성

<br/>

# 3장 패턴 구조화 및 작성

## 디자인 패턴의 구성 요소

- 이름
- 설명
- 컨텍스트 개요
- 문제 제시
- 해결 방법
- 설계 내용
- 구현 방법
- 시각적 설명
- 예제
- 필수 연계
- 관계성
- 알려진 용도
- 토론

<br/>

# 4장 안티패턴

## 안티 패턴이란?

잘못된 패턴을 의미한다. 겉으로만 해결책처럼 생긴 패턴.

# 자바스크립트 안티 패턴

## 1. `<script>`는 문서 하단에서 포함한다.

- `head`에 script가 있으면 브라우저는 `script`를 다운로드하고 실행할 때까지 페이지 렌더링을 중단한다.
- `head`에 있는 `script`는 `body`의 `DOM`요소들이 생성되기 전에 실행된다. 따라서 `script`에서 `DOM`요소에 접근하려고 하면 에러가 발생할 수 있다,

```tsx
<!DOCTYPE html>
<html>
  <head>
    ...
    <!-- Bad: head 태그 안에서 script 삽입 -->
    <script src="../js/jquery-3.3.1.min.js"></script>
    <script src="../js/common.js"></script>
    <script src="../js/applicationMain.js"></script>
  </head>
  <body>
    ...
    <!-- Good: body 태그 안, 맨 마지막에 삽입 -->
    <script src="../js/jquery-3.3.1.min.js"></script>
    <script src="../js/common.js"></script>
    <script src="../js/applicationMain.js"></script>
  </body>
</html>
```

최신 방식

- `defer`: HTML 파싱이 완료될 때까지 script 실행을 지연
- `async`: 비동기적으로 실행

```tsx
<head>
    <!-- defer 속성 사용 -->
    <script src="app.js" defer></script>

    <!-- 또는 async 속성 사용 -->
    <script src="analytics.js" async></script>
</head>
```

## 2. 배열의 순회는 `for-in`을 사용하지 않는다.

- 보통 객체(object)의 프로퍼티 순회가 필요할때는 `for-in`을 사용한다.
- 자바스크립트의 배열도 객체지만 배열의 요소를 순회할 때는 `for-in`을 사용하지 않아야 한다.
- `for-in`은 프로토타입 체인에 있는 모든 프로퍼티를 순회하므로 `for`를 사용할 때보다 훨씬 느리다.
- 게다가 순회 순서는 브라우저에 따라 다르게 구현되어 있어서 배열의 요소 순회가 늘 index 순서대로 수행되지 않을 수 있다.

```tsx
Array.prototype.customMethod = function () {};
const arr = [1, 2, 3];

// for-in 사용 시 문제점
for (let i in arr) {
  console.log(i); // "0", "1", "2", "customMethod"
}
```

## **3. `setTimeout`, `setInterval` 사용 시 콜백 함수는 문자열로 전달하지 않는다**

내부에서 `eva`l로 처리되어 실행속도가 느려진다.

```tsx
// Bad
function callback() {
  ...
}

setTimeout('callback()', 1000);

// Good (1)
function callback() {
  ...
}

setTimeout(callback, 1000);

// Good (2)
setTimeout(() => {
    ...
}, 1000);
```

## 4. 단항 연산자 사용하지 않는다.

주로 코드의 가독성과 명확성이 떨어지는 문제로 사용하지 않는 것이 좋다.

```tsx
// 문제가 될 수 있는 코드
let a = 1;
let b = a++ + ++a; // 매우 혼란스러움
console.log(b); // 결과 예측이 어려움

let a = 1;

// 더 명확한 방식
a += 1;
// 또는
a = a + 1;
```

<br/>

# 5장 최신 자바스크립트 문법과 기능

## 모듈 객체

모듈을 객체로 가져오면 객체 하나만으로 여러 곳에 사용할 수 있다.

```tsx
import * as Staff from './any';

export const oven = {
  makeCupcake(toppings) {
    Staff.baker.bake();
  },
  makePastry(size) {
    Staff.pastryChef.make();
  },
};
```

## 외부 소스로부터 가져오는 모듈

외부소스에서 가져오는 원격모듈

```tsx
import { cakeFactory } from 'https://example.com/modules/cakeFactory.mjs';
// 미리 로드된 정적 가져오기

cakeFactory.oven.makeCupcake();
```

## 정적으로 모듈 가져오기

정적 가져오기는 메인 코드를 실행하기 전에 먼저 모듈을 다운로드하고 실행해야 한다.

따라서 초기 페이지 로드 시 많은 코드를 미리 로드해야 하므로 문제가 생길 수 있다.

```tsx
import { cakeFactory } from '/modules/cakeFactory.mjs';
// 미리 로드된 정적 가져오기

cakeFactory.oven.makeCupcake();
```

## 동적으로 모듈 가져오기

지연 로딩 모듈을 사용하면 필요한 시점에 로드할 수 있다.동적 가져오기는 함수와 비슷한 새로운 형태의 가져오기다.

`import`는 요청된 모듈의 네임스페이스 객체에 대한 `프로미스 객체를 반환`한다. 이 프로미스 객체는 모듈 자체와 모든 모듈 의존성을 가져온 후, 인스턴스화하고 평가한 뒤에 만들어진다.

```tsx
form.addEventListener('submit', e => {
  e.preventDefault();
  import('/modules/cakeFactory.js').then(module => {
    module.oven.makeCupcake('sprinkles');
  });
});
```

동적 가져오기는 `await` 키워드와 함께 사용할 수 있다.

```tsx
let module = await import('/modules/...');
```

동적 가져오기를 사용하면 모듈이 사용될 때만 다운로드되고 실행된다.

## 서버에서 모듈 사용하기

Node는 `type`이 `module`이라면 `.mjs`와 `.js`로 끝나는 파일을 자바스크립트 모듈로 취급한다.

## 모듈 사용 이점

### 1. 한 번만 실행된다.

기존 스크립트는 DOM에 추가될 때마다 실행되는 반면에 모듈 스크립트는 한 번만 실행된다.

### 2. 자동으로 지연 로드된다.

즉시 로드되지 않기 위해 다른 스크립트 파일은 defer 속성을 붙여야 하지만, 모듈은 자동으로 지연되어 로드된다.

### 3. 유지보수와 재사용이 쉽다.

모듈은 다른 모듈에 영향을 주지 않고 독립적으로 실행될 수 있는 코드 조각으로 관리된다.

### 4. 네임스페이스를 제공한다.

모듈은 관련 변수와 상수를 위한 개별 공간을 생성하여 글로벌 네임스페이스를 오염시키지 않고 모듈 참조를 통해 사용할 수 있게 한다.

### 5. 사용하지 않는 코드를 제거한다.

웹팩이나 롤업 같은 번들러를 사용해 트리쉐이킹 할 수 있다.

## 클래스

ES2015+에서는 모듈뿐만 아니라 생성자와 내부를 숨기는 기능을 가진 클래스가 추가되었다.

```tsx
class Cake {
  constructor(name, toppings, price, cakeSize) {
    this.name = name;
    this.cakeSize = cakeSize;
    this.toppings = toppings;
    this.price = price;
  }

  addTopping(topping) {
    this.toppings.push(topping);
  }

  get allToppings() {
    return this.toppings;
  }

  getQualifiesForDiscount() {
    return this.price > 5;
  }

  set size(size) {
    if (size < 0) {
      throw new Error('Cake must be a valid size');
    }
    this.cakeSize = size;
  }
}

const cake = new Cake('chocolate', ['chocolate chips'], 5, 'large');
```

자바스크립트의 클래스는 프로토타입을 기반으로 하고 있으며, 사용하기 전에 미리 정의해야한다.

`extends` 키워드를 통해 클래스를 상속 받을 수 있다.

```tsx
class BirthdayCake extends Cake {
  surprise() {
    console.log('Happy Birthday!');
  }
}

const birthdayCake = new BirthdayCake(
  'chocolate',
  ['chocolate chips'],
  5,
  'large',
);
birthdayCake.surprise();
```

부모클래스의 생성자를 실행할 수 있는 `super` 키워드도 지원한다. 이는 자기 상속 패턴을 사용할 때 유용하다.

주의 사항은 `super()`를 먼저 호출해야 한다. `super` 호출 전에는 `this`를 사용할 수 없다.

```tsx
class Cookie {
  constructor(flavor) {
    this.flavor = flavor;
  }

  showTitle() {
    console.log(`The flavor of this cookie is ${this.flavor}.`);
  }
}

class FavoriteCookie extends Cookie {
  showTitle() {
    super.showTitle();
    console.log(`${this.flavor} is amazing.`);
  }
}

let myCookie = new FavoriteCookie('chocolate');
myCookie.showTitle();
```
