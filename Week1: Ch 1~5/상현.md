# 상현

## 1장. 디자인 패턴 소개

### 1.2 패턴이란 무엇인가?

패턴: 소프트웨어 설계에서 반복되는 문제와 주제에 적용할 수 있는 재사용 가능한 템플릿

유용한 이유:

- 검증: 앞선 개발자들의 경험과 통찰의 산물
- 쉬운 재사용: 사용자의 요구에 맞춰 적용
- 알아보기 쉬움: 정해진 구조와 공통 표현을 사용

패턴의 이점

- 개발과정의 사소한 실수로 생길 수 있는 큰 문제를 방지
  - 정해진 패턴을 통해서 코드 구조가 잘 못될 염려 저하 및 개발에 집중. 또한 자연스럽게 체계적인 코드를 작성이되어서 리팩터링 상황 방지
- 특정 문제에 국한되지 않은 종합적인 해결책 제시
  - 어플리케이션의 형태 또는 언어에 상관없이 적용 가능
- 반복을 피함으로써 전체 코드의 양 감소
  - 일반화된 함수를 사용하는 방법을 통해서 불필요한 반복을 방지(DRY)
- 공통된 어휘를 사용하여 의사소통이 원할
  - 디자인 패턴에 대한 토론 및 유지보수 패턴을 이야기 할 수 있음
- 인기 있는 디자인 패턴은 커뮤니티의 선순환 유발
  - 기존 패턴을 개선 또는 새로운 패턴의 탄생을 유발

## 2장. 패턴성 검증, 프로토 패턴 그리고 세 가지 법칙

### 2.1 프로토 패턴이란?

패턴은 “과정”인 동시에 “결과”. 따라서 새롭게 발견된 패턴이 있더라도 결과를 검증하기 전까지 패턴으로 간주하지 않고 “프로토 패턴”이라고 명명

### 2.2 패턴성 검증

프로트 패턴이 다음과 같은 특징을 가지고 있으면 좋은 패턴으로 간주

- 특정 문제 해결 가능: 단순 원리나 방법이 아닌 문제를 해결할 수 있어야 함
- 명쾌한 해결책이 없음: ????
- 확실한 기능만 제공: 설명대로 잘 작동. 그렇지 않으면 사용 고려X
- 관계를 설명: 코드와의 관계를 나타내는 심층 구조와 메커니즘을 서술

### 2.3 세 가지 법칙

좋은 패턴은 반복되는 현상 또는 문제에 지속적으로 사용되어야 하고 반복성을 입증하기 위해 다음 세 가지 법칙에 부합

- 목적 접합성: 좋은 패턴은 어떻게 판단?
- 유용성: 좋은 패턴이라고 할 수 있는 이유?
- 적용 가능성: 넓은 적용 범위를 가지고 있어 패턴이 될 가치가 있는가? 그렇다면 그 이유는?

## 3장. 패턴 구조화 및 작성

다른 개발자들이 디자인 패턴을 올바르게 이해하고 채택할 수 있도록 관련 맥락이나 상황, 사전 요구 사항 및 적절한 예제가 충분히 제공

### 3.1 디자인 패턴의 구조

규칙의 형태:

- 컨택스트: 패턴이 적용되는 상황
- 집중 목표: 패턴을 적용할 때 고려해야 하는 목표
- 구성: 제시된 상황과 고려해야 하는 점들을 해결하는 구성

패턴의 구성 요소 **(앞 5개가 가장 중요)**:

- 이름: 패턴의 목적을 드러내는 이름
- 설명: 패턴이 무엇을 해결할 수 있는지에 대한 간단한 설명
- 컨택스트 개요: 패턴이 사용자의 요구에 부합하는지에 대한 설명
- 문제 제시: 패턴을 만든 의도를 알 수 있도록 문제를 제시
- 해결 방법: 이해하기 쉬운 간계와 개념을 통해 문제가 어떻게 해결되는 지에 대한 설명
- 설계 내용: 패턴의 설계와 사용자가 어떻게 사용할 수 있는지에 대한 설명 필요
- 구현 방법: 패턴을 구현하는 방법에 대한 지침 필요
- 시각적 설명: 다이어그램처럼 패턴을 나타내는 시각적 설명
- 예제: 패턴을 구현한 예시
- 필수 연계: 해당 패턴과 함께 사용하면 좋은 패턴에 대한 내용
- 관계성: 다른 패턴과의 관계 및 유사점에 대한 내용
- 알려진 용도: 업계에서 이미 쓰이던 패턴인지에 대한 설명
- 토론: 해당 패턴의 이점에 대한 사람들의 의견

### 3.2 모범 패턴

패턴의 구조와 목적을 이해하면 해당 패턴이 필요한 이유를 더 알 수 있음
또한, 좋은 패턴은 충분한 참고 자료 + 패턴이 필요한 이유를 제공.

### 3.3 패턴 작성하기

직접 개발 또는 개선하고 싶을 때는 이미 잘 만들어진 다른 패턴 참고가 좋은 방법:

- ‘모듈 패턴’을 참고하여 ‘노출 모듈 패턴’을 만들어낸 크리스티안 하일만

참고할 시 다음 체크리스트를 확인

- 실용적: 반복되는 문제에 대한 해결책이 있는지
- 모범 사례 생각: 설계는 모범 사례를 이해하여 도출해 낸 원칙에 기반
- 사용자에게 솔직: 사용자 경험이 솔직. 예상되는 사용자 경험을 맘대로 바꿔서는 안됨
- 독창성은 패턴 설계의 핵심X: 겹치거나 최초일 필요 없고 넓게 적용할 수 있다면 유용한 패턴으로 인정
- 훌륭한 예시 필요: 올바른 적용 방법을 보여주는 효과적인 예시 필요

## 4장. 안티 패턴

### 4.1 안티 패턴이란?

안티 패턴은 **겉으로만 해결책으로 생긴 패턴.** 그러나 상황에 따라서 패턴이 좋고 나쁨이 결정됨. 이런 것을 문서화하면 반면 교사로 활용하기 좋음.

나쁜 디자인 패턴을 안다는 것은 실수를 피하고 어떤 것이 유명하고 유용한 표준 기술인지 알 수 있게 해줌

### 4.2 자바스크립트 안티 패턴

- 전역 변수, setTimeout 및 setInterval에 함수가 아닌 문자열 전달하여 eval() 실행, Object클래스의 프로토타입 수정 등등…

## 5. 최신 자바스크립트 문법과 기능

### 5.1 애플리케이션 분리의 중요성

모듈로 잘게 분리되어 의존성을 낮추거나 유지보수를 용이하게 설정.
ES6 이전에는 CommonJS나 AMD가 사용이 되었지만, ES6부터는 모듈형으로 전환 및 현재는 표준으로 잡힘

### 5.3 모듈 객체

```tsx
import * as Staff from "./경로..."

Staff.baker.bake(....)
```

### 5.4 외부 소스로부터 가져오는 모듈

```tsx
import { cakeFactory } from "https://example.com/modules/cakeFactory.mjs";
```

### 5.5 & 5.6 정적 모듈 및 동적 모듈

```tsx
// 정적: 미리 설치한 것을 가져오기
import { cakeFactory } from "/modules/경로..."

// 동적: 특정 상황에서 가져오기
// 1. form 이벤트가 발생했을 때
form.addEventListener("submit", e => {
	e.preventDefault();
	import(''/modules/⊂akeFactory.js'')
		.then((module)=> {
		//가져온모듈사용하기
		module.oven.makeCupcake(''sprinkles'');
		module.oven.make빠uffin("1arge")j
		});
));

// 2. 동적할당
let module = await import("/modules/cakeFactory‘js");

// 3. 화면에 보이면 불러오기
// 예: IntersectionObserver API 사용

```

### 5.7 서버에서 모듈 사용하기

```tsx
{
	"name": "jS-modules",
	"version": "1.0.0",
	"description": "A package using JS Nodules",
	"main": "index.js",
	"type": "module", // 이 flag로 모듈 취급
	"author": "",
	"1icense": "MIT"
)
```

### 5.8 모듈을 사용하면 생기는 이점

1. 한 번만 실행: 기존 스크립트는 DOM에 추가될 때마다 실행되지만 모듈은 한 번만 실행
2. 자동으로 지연 로드: 다른 스크립트 파일을 defer 속성을 써야 하지만 모듈은 자동으로 지연 로드
3. 유지보수와 재사용이 쉽다: 독립적으로 실행될 수 있는 코드이기에 재사용 가능
4. 네임스페이스 제공: 글로벌 네임스페이스가 아닌 개별 공간을 사용하기에 글로벌 네임스페이스 오염 방지
5. 사용하지 않는 코드 제거: 번들러를 통해서 트리쉐이킹 가능

### 5.9 생성자, 게터, 세터를 가진 클래스

```tsx
class Cake{
	// 생성자 연에서 변수를 정의합니다.
	constructor( name, toppings, price, cakesize ){
		this.name=name;
		this.cakesize=cakesize;
		this.toppings=toppings5
		this.price=price;
	}

	// ES2015 버전 이상에서는 모든 것을 함수로 만드는 것을 피하고자
	// 새로운 식별자를 사용하려고 했습니다.
	addTopping( topping ){
		this.toppings.push(topping);
	}
	// 게터는 메서드 이름 앞에 넣어 사용합니다.
	get aUToppings(){
		retumthis.toppings;
	}
	get qualifiesForDi5count(){
	 returnthis.price>5;
	}

	// 세터도 메서드 이름 앞에 넣어 사용합니다.
	set size( size ){
		if( size < 0){
			throw new Error('Cake must be a valid size' + 'either small, medium or large');
		}
		this.cakeSzie = size
	}
}

// 사용 방법
1et cake = new Cake( "chocolate", ["chocolate chips"], 5, "large" );

// extneds를 통한 확장
class CookieCake extends Cake {
	.....
}
```
