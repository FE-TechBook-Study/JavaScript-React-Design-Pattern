# 하린

# 8. 자바스크립트 MV\* 패턴

## 8.1 MVC 패턴

애플리케이션의 구조를 개선하기 위해 관심사의 분리를 활용하는 아키텍쳐 디자인 패턴

- 구성요소
  - 모델 : 애플리케이션에 필요한 비즈니스 데이터를 관리하는 역할
  - 뷰 :
    - 애플리케이션 데이터를 시각적으로 표현합니다.
    - 모델을 관찰하고, 모델에 변화가 생기면 알림을 받아 UI를 업데이트할 수 있습니다.
    - 사용자는 뷰 내의 요소를 클릭하는 등의 동작으로 모델의 데이터를 읽고 수정하는 상호작용을 할 수 있습니다.
    - 이때 실제 클릭 동작을 처리하는 역할은 컨트롤러에 위임하여 모델을 실제로 업데이트 하는 작업은 컨트롤러가 담당합니다.
  - 컨트롤러
    - 모델과 뷰 사이의 중재자 역할, 일반적으로 사용자가 뷰를 조작할 때 모델을 업데이트 하는 역할을 합니다.
    - 애플리케이션 내에서 모델과 뷰 간의 로직과 연동을 관리합니다.

### 템플릿

템플릿은 뷰를 생성하기 위해 사용되며, 태그 탬플릿 리터럴 문자열을 사용해 동적인 HTML 콘텐츠를 깔끔하게 만들 수 있도록 해줍니다.

## 8.3 MVC를 사용하는 이유는?

MVC에서의 관심사 분리는 애플리케이션의 기능을 더 간단한 모듈로 나눌 수 있도록 해주며, 다음과 같은 이점을 제공합니다.

- [유지보수의 단순화]
  애플리케이션 업데이트시, 변경사항이 데이터 중심(모델과 컨트롤러의 변경)인지 UI의 변경(뷰의 변경)인지 명확하게 구분할 수 있습니다.
- [모델과 뷰의 분리]
  비즈니스 로직에 대한 단위 테스트 작성이 훨씬 간편해집니다.
- [중복 코드 제거]
  애플리케이션 전반에서 하위 수준의 모델 및 컨트롤러 코드 중복이 제거됩니다.
- [모듈화를 통한 동시 작업 가능]
  규모와 역할의 분리 정도에 따라, 모듈화를 통해 코어 로직 담당 개발자와 UI 담당 개발자가 동시에 작업할 수 있습니다.

---

## 8.6 MVP 패턴

Model-View-Presenter 패턴은 프레젠테이션 로직의 개선에 초점을 맞춘 MVC 패턴의 파생입니다.

MVC, MVP 모두 여러 구성 요소 간의 관심사 분리를 목표로 하지만, 몇 가지 근본적인 차이점이 있습니다.

### 모델, 뷰, 프리젠터

MVP에서 P는 프리젠터를 의미합니다.

프리젠터는 뷰에 대한 UI 비즈니스 로직을 담당하는 구성 요소입니다.

모델을 관찰하고 모델이 변경될 때 뷰를 업데이트하여 MVC에서 컨트롤러 처럼 모델과 뷰를 연결해줍니다.

MVC와 달리 뷰에서의 이벤트 호출은 프리젠터로 위임됩니다. 뷰와 분리되어 있으며, 인터페이스를 통해 뷰와 통신합니다.

### **MVP와 MVC**

- **MVP**
  - **특징**: 프레젠테이션 로직을 재사용해야 하는 복잡한 애플리케이션에 적합
  - **장점**:
    - 뷰가 인터페이스로 정의되어 있어 뷰와 프레젠터를 명확히 분리
    - UI와 프레젠테이션 로직을 독립적으로 개발 가능
    - 단위 테스트가 용이 (프레젠터를 모킹하여 독립적인 테스트 가능)
  - **한계**:
    - 구현 방식과 개발 언어에 따라 적용 방식에 차이 존재
    - 근본적인 문제는 MVC와 공유
- **MVC**
  - 뷰, 모델, 컨트롤러로 역할을 분리
  - 복잡한 로직이 필요한 경우 여러 컨트롤러에 의존하게 될 수 있음
  - 전통적인 MVC는 자바스크립트 프레임워크에서 엄격히 구현되지 않음

---

## **8.7 MVVM 패턴**

- **개요**: MVC와 MVP 기반의 아키텍처 패턴으로 UI와 비즈니스 로직을 명확히 분리
- **구성 요소**:
  - **모델**: 도메인 데이터와 데이터 유효성 검사를 담당
  - **뷰**: UI 요소와 사용자 상호작용의 중심. 데이터 바인딩을 통해 상태를 동기화
  - **뷰모델**:
    - 데이터 변환기 역할
    - 모델 데이터를 뷰가 이해할 수 있는 형태로 변환
    - 뷰에서 발생한 명령을 모델로 전달
    - 상태 관리 및 데이터와 사용자 동작 간의 다리 역할 수행

### **MVVM의 특징**

- **양방향 데이터 바인딩**: 뷰와 뷰모델 간의 데이터와 상태를 동기화.
- **역할 분담**:
  - 뷰는 UI 이벤트 처리 및 뷰모델과 연결
  - 뷰모델은 모델 데이터 제공, 데이터 변환, 유효성 검사 등을 담당
  - 모델은 비즈니스 데이터와 유효성 검사만 수행

### **MVVM의 장단점**

- **장점**:
  - UI와 비즈니스 로직의 동시 개발 가능
  - 뷰 추상화로 비즈니스 로직 단순화
  - 이벤트 중심 코드보다 단위 테스트가 용이
  - 뷰모델은 독립적으로 테스트 가능
- **단점**:
  - 단순한 UI에 적용 시 과도한 구현 부담
  - 데이터 바인딩으로 디버깅이 어려울 수 있음
  - 복잡한 애플리케이션에서는 데이터 바인딩 관리 부담 증가
  - 대규모 애플리케이션에서 뷰모델 설계의 어려움 존재

---

## **8.9 MVC vs MVP vs MVVM**

- **MVC (Model-View-Controller)**:
  - **구조**: 뷰는 컨트롤러와 직접 상호작용하며, 컨트롤러는 모델을 관리
  - **특징**: 뷰가 모델에 직접 접근 가능, 단순하지만 보안 및 성능 문제 발생 가능
  - **장점**: 모델 데이터를 변환 없이 바로 사용 가능해 성능 우수
  - **단점**: 뷰와 모델 간의 강한 연결로 복잡한 애플리케이션에선 비효율적
- **MVP (Model-View-Presenter)**:
  - **구조**: 프리젠터가 뷰와 모델 사이에서 중재 역할 수행. 뷰는 프리젠터를 통해서만 모델에 접근
  - **특징**: 뷰와 프리젠터는 인터페이스로 연결되어 명확히 분리
  - **장점**: 뷰와 모델이 독립적이라 테스트 용이. 복잡한 애플리케이션에 적합
  - **단점**: 뷰와 프리젠터 간 강한 의존성
- **MVVM (Model-View-ViewModel)**:
  - **구조**: 뷰모델이 뷰와 모델 사이에서 데이터와 상태를 관리. 데이터 바인딩으로 뷰와 뷰모델 동기화
  - **특징**: 뷰모델이 뷰를 참조하지 않고, 뷰가 뷰모델을 바인딩
  - **장점**: 뷰와 로직 분리로 테스트 용이, 데이터 바인딩으로 코드 간소화
  - **단점**: 데이터 바인딩과 변환 로직이 복잡해질 경우 성능 문제 발생 가능

---

## 8.10 최신 MV\* 패턴

- **과거 프레임워크**: Backbone.js, KnockoutJS 등은 더 이상 인기가 없으나 초기 아키텍처 이해에 유용
- **현대 프레임워크**:
  - **React**:
    - UI 구축을 위한 라이브러리, MVC 프레임워크가 아님
    - 상태(모델), 렌더링(뷰), 로직(컨트롤러 역할)을 컴포넌트로 수직 분할
    - 선언형 프로그래밍 방식으로 데이터 기반 뷰 렌더링
    - 컴포넌트 로직은 Hooks로 구성, "모델 -> 비동기 데이터, 뷰 -> 컴포넌트, 컨트롤러 -> Hook" 구조로 이해 가능
  - **Vue.js**:
    - MVVM 패턴을 공식적으로 지향
    - 데이터 바인딩과 상태 관리가 용이
- **Next.js**:
  - React 기반 프레임워크로 서버사이드 렌더링(SSR)과 정적 사이트 생성(SSG) 지원
  - 백엔드 역할을 통해 MVC와 유사한 동작 수행 가능
  - 서버에서 데이터베이스와 상호작용하고 뷰를 사전 렌더링, 이후 React로 뷰를 동적으로 업데이트

# 9. 비동기 프로그래밍 패턴

## 9.1 비동기 프로그래밍

비동기 코드는 논블로킹 방식으로 실행됩니다.

자바스크립트 엔진은 현재 실행 중인 코드가 다른 작업을 기다리는 동안 백그라운드에서 해당 비동기 코드를 실행할 수 있습니다.

---

## 9.3 프로미스 패턴

프로미스(Promise)는 비동기 작업의 결과를 나타내는 객체로, 대기(`pending`), 완료(`fullfilled`), 거부(`rejected`)의 세 가지 상태를 갖습니다.

**Promise 생성자**를 사용하며, 함수의 인수로 `resolve`, `reject`를 전달받습니다.

```jsx
const promise = new Promise((resolve, reject) => {
  // 작업 성공 시 resolve 호출
  // 작업 실패 시 reject 호출
});
```

- 장점
  - 비동기 작업 처리의 **가독성** 향상.
  - **콜백 지옥(callback hell)** 회피.
  - 유지보수성 높은 코드 작성 가능.

### 프로미스 병렬 처리

`Promise.all` 메서드를 사용하여 여러 프로미스를 동시에 실행할 수 있게 해줍니다.

```jsx
Promise.all([
  makeRequest("http://example.com/1"),
  makeRequest("http://example.com/2"),
]).then(([data1, data2]) => {
  console.log(data1, data2);
});
```

### 프로미스 순차실행

`Promise.resolve` 메서드를 사용하여 순차적으로 실행할 수 있도록 해줍니다.

```jsx
Promise.resolve()
  .then(() => console.log("Promise 1 resolved"))
  .then(() => console.log("Promise 2 resolved"))
  .then(() => console.log("Promise 3 resolved"))
  .then(() => console.log("Promise 4 resolved"));
```

### 프로미스 메모이제이션

캐시를 사용하여 프로미스 함수 호출의 결과값을 저장하여 중복 호출을 방지합니다.

```jsx
const cache = new Map();

function memoizedMakeRequest(url) {
  if (cache.has(url)) return cache.get(url);

  return new Promise((resolve, reject) => {
    fetch(url)
      .then((res) => res.json())
      .then((data) => {
        cache.set(url, data);
        resolve(data);
      })
      .catch((err) => reject(err));
  });
}
```

## 9.4 async/await 패턴

async/await는 비동기 코드를 마치 동기 코드처럼 작성할 수 있게 해주는 자비스크립트의 기능입니다. async/await는 프로미스를 기반으로 구축되었으며, 비동기 코드 작업을 보다 쉽고 간결하게 만들어줍니다.

### 비동기 반복

`for-await-of` 반복문을 사용하여 비동기 반복 가능 객체를 순회합니다.

```jsx
async function* createAsyncIterable() {
  yield 1;
  yield 2;
  yield 3;
}

async function main() {
  for await (const value of CreateAsynclterable()) {
    console.log(value);
  }
}
```

### 비동기 병렬

Promise.all 메서드를 사용하여 여러 비동기 작업을 동시에 실행할 수 있게 합니다.

```jsx
async function main() {
  const [data1, data2] = await Promise.all([
    makeRequest("http://example.com/1"),
    makeRequest("http://example.com/2"),
  ]);
  console.log(data1, data2);
}
```

### async/await 데코레이터

고차 함수를 사용하여 데코레이터를 생성하여 비동기 함수에 적용되어 추가적인 기능을 제공합니다.

```jsx
function asyncDecorator(fn) {
  return async function (...args) {
    try {
      return await fn(...args);
    } catch (error) {
      throw error;
    }
  };
}

const makeRequest = asyncDecorator(async function (url) {
  const response = await fetch(url);
  const data = await response.json();
  return data;
});

makeRequest("http://example.com/").then((data) => {
  console.log(data);
});
```
