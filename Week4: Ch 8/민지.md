# 민지

# 자바스크립트 MV\* 패턴

애플리케이션 설계에는 객체의 설계, 애플리케이션 아키텍처라는 두가지 중요한 측면이 있다.

## 8.1 MVC 패턴

- 애플리케이션의 구조를 개선하기 위해 관심사의 분리를 활용하는 아키텍처 디자인 패턴
- 비즈니스 데이터(Model)과 UI(View)를 분리하고, 세번째 구성 요소(Controller)가 로직과 사용자 입력을 관리하는 구조

### 8.1.1 Smalltalk-80의 MVC패턴

- Smalltalk-80에서 구현된 MVC는 애플리케이션의 로직과 UI를 분리하는 것을 목표로 했다.
  - 애플리케이션의 일부분을 분리함으로써 모델을 애플리케이션의 다른 인터페이스에서도 재사용 할 수 있다는 점을 기본 개념으로 둔다.
  - Model
    - 도메인 관련 데이터를 표현했으며 UI에 대해서는 관여하지 않는다. 모델이 변경되면 자신의 관찰자 객체에게 알림을 보낸다.
  - View
    - 모델의 현재 상태를 표현한다.
    - 관찰자 패턴을 사용해 모델이 변경되거나 수정될 때마다 뷰가 알 수 있도록 했으며 뷰는 화면에 보여지는 프레젠테이션 부분만을 담당했지만, 화면에 표시되는 각 섹션 또는 요소에는 언제나 뷰-컨트롤러 쌍이 존재했다.
  - Controller
    - 키보드 입력이나 클릭 같은 사용자의 상호작용을 처리하고 뷰에 무엇을 보여줄지, 사용자 입력을 어떻게 처리할지 등을 결정하는 역할
- [MVC 기원에 대한 훌륭한 글](https://martinfowler.com/eaaDev/uiArchs.html)

## 8.2 자바스크립트의 MVC

- 현재 자바스크립트는 MVC를 지원하는 여러 프레임워크를 갖추고 있어, 쉽게 MVC 패턴을 사용할 수 있다.
- 구조의 결함 때문에 읽기 어렵고 유지 관리하기 힘든 코드를 뜻하는 스파게티 코드를 피하는 것이 중요하다는 점을 고려할 때 현대 자바스크립트 개발자는 MVC 패턴과 그 변형 버전들이 제공하는 장점을 이해해야 한다.

### 8.2.1 모델

- 애플리케이션의 데이터를 관리하는 역할을 한다.
- UI나 프레젠테이션 계층은 담당하지 않고, 애플리케이션에 필요한 고유 데이터 형식을 나타낸다.
- 모델이 변경될 때 관찰자에게 변경사항을 알리고 관찰자가 변경된 내용에 알맞게 능동적으로 대응할 수 있게끔 한다.
- ex) 사진 갤러리 애플리케이션
  - 사진 : 고유한 도메인 관련 데이터를 보여주므로 사진은 독자적인 모델이 될 수 있다.
  - 이러한 모델에는 설명, 이미지 소스, 추가 메타데이터와 같은 관련 속성들이 포함될 수 있으며 특정 사진은 모델의 인스턴스로 저장되어 재사용도 가능하다.
- 모델의 내장 기능은 프레임워크마다 다를 수 있으나 대게 모델의 속성을 검증하는 기능을 지원한다.
- 한가지 모델을 여러 뷰가 관찰할 수도 있다.
- 모델을 컬렉션으로 그룹화하는 기능을 제공하는 경우가 많다. 모델을 그룹으로 관리하면 그룹 내의 특정 모델이 변경될 때 그룹의 알림을 기반으로 애플리케이션의 로직을 작성할 수 있어, 개별 모델 인스턴스를 직접 관찰할 필요가 없어진다.
- **모델은 비즈니스 데이터와 주로 관련이 있다.**

### 8.2.2 뷰

- 모델에 대한 시각적인 표현으로 현재 상태의 특정 부분만 보여준다.
- 자바스크립트의 뷰는 여러 DOM 요소의 집합을 생성하고 정리하는 역할을 한다.
- 일반적으로 뷰는 모델을 관찰하고, 모델에 변화가 생기면 알림을 받는다. 이를 통해 뷰는 스스로를 업데이트 할 수 있다.
- 사용자는 뷰와 상호작용할 수 있다. (= 모델의 데이터를 읽고 속성 값을 가져오거나 설정 가능)
- 모델을 실제로 업데이트 하는 작업은 컨트롤러가 담당한다.

```jsx
const buildPhotoView = (photoModel, photoController) => {
	const base = document.createElement("div")
	const photoEl = document.createElement("div")

	base.appendChild(photoEl)

	const render = () => {
		photo entry
		photoEL.innerHTML = _.template('#photoTemplate', {
			src : photoModel.getSrc()
		})
	}

	photoModel.addSubscriber(render)

	photoEl.addEventListener("click", ()=>{
		photoController.handleEvent("click", photoModel)
	})

	const show = () => {
		photoEl.style.display = ""
	}

	const hide = () => {
		photoEl.style.display = "none"
	}

	return {
		showView : show,
		hideView : hide
	}
}
```

### 8.2.3 템플릿

- 템플릿은 뷰와 연관된다.
- 스크립트로 동적 생성된 마크업을 표준 마크업에 포함시키게 되는데 이는 마크업의 가독성이 빠르게 저하될 뿐만 아니라, 복잡한 애플리케이션에서 이러한 코드 관리는 유지보수에 재앙을 불러 일으킬 수 있다.
- 최신 자바스크립트 템플릿 솔루션은 태그 템플릿 리터럴의 사용으로 방향을 전환했다.
  - 태그 템플릿 리터럴을 사용하면 자바스크립트의 템플릿 리터럴 문법과 함께 템플릿을 조작하고 데이터를 채우는 데 사용할 수 있는 커스텀 처리 함수를 통해 재사용 가능한 템플릿을 만들 수 있다.
- 템플릿 자체는 뷰가 아니다. 프레임워크가 템플릿 명세에 따라 뷰를 생성할 수 있도록, 템플릿은 뷰 객체의 일부 또는 전체를 선언적으로 지정하는 방법이 될 수 있다.

### 8.2.4 컨트롤러

- 모델과 뷰 사이의 중재자 역할을 하며, 일반적으로 사용자가 뷰를 조작할 때 모델을 업데이트 하는 역할이다.
- 애플리케이션 내에서 모델과 뷰 간의 로직 및 연동을 관리한다.

## 8.3 MVC를 사용하는 이유는?

- MVC에서의 관심사 분리는 애플리케이션의 기능을 더 간단한 모듈로 나눌 수 있도록 해주며 다음과 같은 이점을 제공한다.
  - 전반적인 유지보수의 단순화
  - 모델과 뷰의 분리
  - 애플리케이션 전반에서 하위 수준의 모델 및 컨트롤러 코드 중복이 제거된다.
  - 애플리케이션의 규모와 역할의 분리 정도에 따라, 모듈화를 통해 코어 로직을 담당하는 개발자와 UI 작업을 담당하는 개발자가 동시에 작업할 수 있다.

## 8.6 MVP 패턴

- MVP (Model-View-Presenter)
  - 프레젠테이션 로직의 개선에 초점을 맞춘 MVC 디자인 패턴의 파생
- MVC와 MVP 모두 여러 구성 요소간의 관심사 분리를 목표로 하지만, 몇가지 차이점이 있다.

### 8.6.1 모델, 뷰, 프리젠터

- 프리젠터는 뷰에 대한 UI 비즈니스 로직을 담당하는 구성요소
- MVC와 달리, 뷰에서의 이벤트 호출은 프리젠처로 위임된다. 프리젠터는 뷰와 분리되어 있으며, 인터페이스를 통해 뷰와 통신한다.
- 이 방식은 단위 테스트에서 뷰를 모킹할 수 있는 등의 많은 장점을 제공한다.
- MVP는 주로 둔한 수동형 뷰를 활용하는 구현 방식이 가장 널리 사용된다.
- 수동형 뷰는 로직을 거의 가지고 있지 않다.
- MVP에서 P는 모델을 관찰하고 모델이 변경될 때 뷰를 업데이트 한다. P는 모델과 뷰를 효과적으로 연결하는데, 이건 원래 MVC에서 컨트롤러가 담당하던 역할이다.
- 프리젠터는 데이터를 가져오고, 조작하고, 이 데이터가 어떻게 뷰에 표시되어야 하는지 결정한다.
- 이벤트를 구독하여 뷰를 업데이트 할 수 있도록 하는 것이 프리젠터의 역할
- 이러한 수동형 아키텍처에서는 직접적인 데이터 바인딩의 개념이 없다. 대신 뷰는 프리젠터가 데이터를 설정하는 데 사용할 수 있는 세터를 제공한다.
- MVC에서 MVP로의 변화는 애플리케이션의 테스트 용이성을 높이고 뷰와 모델 간의 분리를 더욱 명확하게 해준다는 장점이 있다.
- 그러나 MVP 패턴에는 데이터 바인딩이 지원되지 않기 때문에, 작업을 별도로 처리해야 하는 비용이 발생할 수 있다.

### 8.6.2 MVP vs MVC

- MVP는 일반적으로 프레젠테이션 로직을 최대한 재사용해야 하는 엔터프라이즈 수준의 애플리케이션에서 사용된다.
- 뷰가 매우 복잡하고 사용자의 상호작용이 많은 애플리케이션에서는 MVC가 적합하지 않다.
- MVP에서는 복잡한 로직을 프리젠터 안에 캡슐화할 수 있어 유지보수가 훨씬 간단하다.
- MVC와 MVP 간의 차이점이 대부분 의미론적인 수준이므로, MVC에 존재하는 근본적인 문제들은 MVP에도 동일하게 존재할 가능성이 크다. 하지만 모델, 뷰, 컨트롤러 또는 프리젠터로 관심사를 명확히 분리하기만 한다면, 어떤 패턴을 선택하든지 대부분 동일한 장점을 얻을 수 있다.

## 8.7 MVVM 패턴

- MVVM (Model-View-VIewModel)
  - MVC와 MVP를 기반으로 하는 아키텍처 패턴
  - 애플리케이션의 UI 개발 부분과 비즈니스 로직, 동작 부분을 명확하게 분리
  - 선언적 데이터 바인딩을 활용하여 뷰에 대한 작업을 다른 계층과 분리할 수 있도록 한다.
  - 동일한 코드베이스 내에서 UI 작업과 개발 작업을 거의 동시에 진행할 수 있다.

### 8.7.2 모델

- 다른 MV\* 패턴들과 마찬가지로, MVVM의 모델은 애플리케이션이 사용할 도메인 관련 데이터나 정보를 제공한다.
- 도메인 관련 데이터의 대표적인 예
  - 사용자 계정(이름, 아바타, 이메일)
  - 음악 트랙(제목, 연도, 앨범)
- 모델은 보통 정보를 담고 있으며 동작을 다루지 않는다.
- 모델은 정보 형식을 지원하지 않고, 데이터가 브라우저에 어떻게 표현될지에 영향을 미치지 않는다.
- 데이터 형식 지정은 뷰가 담당하고, 동작은 모델과 상호작용하는 또 다른 계층인 뷰모델에서 캡슐화하여 처리해야 하는 비즈니스 로직으로 간주된다.
- 모델의 역할 중 유일한 예외는 데이터 유효성 검사이다. 기존 모델을 정의하거나 업데이트 하는 데 사용되는 데이터에 대한 유효성 검사는 모델에서 수행하는 것이 허용된다.
  - ex) 입력된 이메일 주소가 특정 정규식의 요구 조건을 충족하는가?

### 8.7.3 뷰

- MVC와 마찬가지로, 뷰는 애플리케이션에서 사용자가 상호작용하는 유일한 부분이고, 뷰모델의 상태를 표현하는 상호작용이 가능한 UI이다.
- 뷰는 수동적이라기보다는 능동적으로 볼 수 있으며 MVC와 MVP의 뷰도 마찬가지이다.
- 뷰는 상태를 관리할 책임이 없다. 뷰는 뷰모델과 정보 또는 상태를 항상 동기화된 상태로 유지하기 때문

### 8.7.4 뷰모델

- 뷰모델은 데이터 변환기의 역할을 하는 특수한 컨트롤러로 볼 수 있다.
- 모델의 정보를 뷰가 사용할 수 있는 형태로 변환하고, 뷰에서 발생한 명령(사용자의 조작이나 이벤트)을 모델로 전달한다.
- 뷰모델은 뷰라기보다는 모델에 더 가깝다고 볼 수 있다. 그러나 동시에 뷰의 디스플레이 로직 대부분을 처리한다. 뷰모델은 뷰의 상태를 유지하고, 뷰에서 발생한 동작에 기반해 모델을 업데이트하며, 뷰에 이벤트를 발생시키는 등의 기능을 수행하기 위한 메서드도 제공할 수 있다.

### 8.7.5 뷰와 뷰모델 복습

- 뷰와 뷰모델은 데이터 바인딩과 이벤트를 통해 소통한다.
- 뷰모델은 모델의 속성을 단순히 제공하는 것뿐만 아니라, 데이터 유효성 검사 같은 다른 메서드와 기능에 대한 접근도 허용한다.
- 뷰는 자체 UI 이벤트를 처리하고, 필요에 따라 뷰모델에 연결한다. 모델과 뷰모델의 속성은 양방향 데이터 바인딩을 통해 동기화되고 업데이트 된다.

### 8.7.6 뷰모델 vs 모델

- 뷰모델은 데이터 바인딩을 위해 모델 또는 모델의 속성을 가져올 수 있고, 뷰에 제공되는 속성을 가져오거나 조작하기 위한 인터페이스를 포함할 수 있다.

## 8.8 장단점

### 8.8.1 장점

- MVVM은 UI와 이를 구동하게 해주는 요소를 동시에 개발할 수 있도록 한다.
- MVVM은 뷰를 추상화함으로써 뷰의 뒤에 작성되는 비즈니스 로직의 양을 줄여준다.
- 뷰모델은 이벤트 중심 코드에 비해 단위 테스트가 더 쉽다.
- 뷰모델은 UI 자동화나 상호작용에 대한 고려 없이도 테스트가 가능하다.

### 8.8.2 단점

- 단순한 UI의 경우, 과도한 구현이 될 수 있다.
- 데이터 바인딩은 선언적이고 사용하기 편리할 수 있지만, 단순히 중단점을 설정하는 명령형 코드에 비해 디버깅이 어려울 수 있다.
- 복잡한 애플리케이션에서는, 데이터 바인딩이 상당한 관리 부담을 만들어 낼 수 있다.
- 대규모 애플리케이션에서는 필요한 일반화를 제공하기 위해 뷰모델을 미리 설계하는 것이 어려울 수 있다.

## 8.9 MVC vs MVP vs MVVM

- MVP와 MVVM은 모두 MVC에서 파생된 패턴이다.
- MVC와 이 파생 패턴들 사이의 핵심 차이점은 각 계층이 다른 계층에 대해 갖는 의존성과, 서로 얼마나 강하게 연결되어 있는지에 있다.

- MVC에서는 뷰가 아키텍처의 최상단에 위치하고 그 옆에는 컨트롤러가 있다. 모델은 컨트롤러 아래에 있기 때문에, 뷰는 컨트롤러에 대해 알고 있고, 컨트롤러는 모델에 대해 알고 있다.
- 이 구조에서 뷰는 모델에 직접 접근할 수 있지만 전체 모델을 뷰에 노출하는 것은 보안 및 성능에 문제를 일으킬 수 있다. → 이러한 문제를 피하기 위해 만들어진 것이 MVVM 패턴

- MVP에서는 컨트롤러의 역할이 프리젠터로 대체된다. 프리젠터는 뷰와 동일한 계층에 존재하며, 뷰와 모델 양쪽에서 발생하는 이벤트를 수신하고 이들 간의 동작을 조정한다,
- MVVM과는 달리, 뷰와 뷰모델을 바인딩하는 메커니즘이 없기 때문에, 각 뷰는 프리젠터가 뷰와 상호작용할 수 있도록 인터페이스를 구현한다.

- MVVM을 사용하면 상태와 로직 정보를 포함할 수 있는 뷰와 관련된 모델 일부를 생성할 수 있다. 이를 통해 전체 모델을 뷰에 노출하는 것을 피할 수 있고 MVP의 프리젠터와 달리, 뷰모델은 뷰를 참조할 필요가 없다. 뷰는 뷰모델의 속성을 바인딩 하여 모델에 포함된 데이터를 뷰에 표현할 수 있다.

## 8.10 최신 MV\* 패턴

- 리액트는 MVC 프레임워크가 아니다. 리액트는 UI 구축을 위한 자바스크립트 라이브러리이며, 주로 SPA 개발에 사용된다.
- 리액트는 뷰 계층을 원하는대로 구성하게 해주는 렌더링 라이브러리이며 기존 MVC와 같이 중앙 제어 역할을 하는 컨트롤러, 혹은 라우터 기능이 포함되어 있지 않다.
- 리액트는 선언형 프로그래밍 방식을 따른다. 즉, 개발자는 애플리케이션이 원하는 상태를 기술하고, 리액트는 그 상태를 기반으로 적절한 뷰를 렌더링한다.
- 리액트를 MVC 디자인 패턴에서 사용하지 않는 이유는 리액트에서 서버가 브라우저에 뷰를 직접 제공하지 않고, 데이터를 제공하기 때문이다. 리액트는 이 데이터를 브라우저에서 구문 분석하여 실제 뷰를 생성한다.

# 비동기 프로그래밍 패턴

- 비동기 자바스크립트 프로그래밍은 브라우저가 이벤트에 응답하여 다른 코드를 실행하는 동안, 백그라운드에서 오랜 시간이 걸리는 작업을 수행하게 해준다.

## 9.1 비동기 프로그래밍

- 자바스크립트에서 동기 코드는 블로킹 방식으로 실행된다.
  - 코드가 순서대로 한번에 한문장씩 실행됨을 의미
  - 코드에서 다음 줄의 문장은 현재 문장의 실행이 완료된 후에만 실행될 수 있다.
  - 동기 함수를 호출하면, 호출자에게 결과를 반환하기 전에 함수 내부의 코드가 처음부터 끝까지 한 줄씩 실행될 것이다.
- 반면 비동기 코드는 논블로킹 방식으로 실행된다.
- 즉, 자바스크립트 엔진은 현재 실행 중인 코드가 다른 작업을 기다리는 동안 백그라운드에서 해당 비동기 코드를 실행할 수 있다.
- 비동기 함수를 호출하면, 함수 내부의 코드가 백그라운드에서 실행되며 호출자에게 즉시 결과가 반환된다.

```jsx
// 동기 코드 예제

function synchronousFunction() {
  // 동기 함수 동작
}
synchronousFunction();
// 이 줄이 오기 전에 함수 내부의 코드를 실행

// 비동기 코드 예제

function asynchronousFunction() {
  // 비동기 함수 동작
}
asynchronousFunction();
// 함수 내부의 코드는 백그라운드에서 실행되며
// 이 줄로 제어권을 반환
```

- 비동기 코드는 코드의 나머지 부분을 차단하지 않고 오래 실행되는 작업을 할 때 유용하다.
  - ex) 네트워크 요청, 데이터베이스 읽기/쓰기, 기타 입출력 작업

```jsx
// 콜백 사용 예시
function makeRequest(url, callback) {
  fetch(url)
    .then((response) => response.json())
    .then((data) => callback(null, data))
    .catch((error) => callback(error));
}

makeRequest("http://example.com/", (error, data) => {
  if (error) {
    console.log(error);
  } else {
    console.log(data);
  }
});

// 콜백을 사용하여 네트워크 요청의 결과를 반환한다.
// 호출자는 makeRequest 함수에 콜백함수를 전달하고,
// 이 콜백 함수는 결과 데이터 또는 에러를 매개 변수로 가져와 사용할 수 있다.
```

```jsx
// promise 사용 예시
function makeRequest(url) {
  return new Promise((resolve, reject) => {
    fetch(url)
      .then((response) => response.json())
      .then((data) => resolve(data))
      .catch((error) => reject(error));
  });
}

makeRequest("http://example.com/")
  .then((data) => console.log(data))
  .catch((error) => console.log(error));

// 네트워크 요청의 결과로 해결되거나 에러로 거부되는 Promise 객체를 반환
// 호출자는 Promise 객체의 .then 메서드와 .catch 메서드를 사용하여 요청 결과를 처리할 수 있다.
```

```jsx
// async, await 사용 예시
async function makeRequest(url) {
  try {
    const response = await fetch(url);
    const data = await response.json();
    console.log(data);
  } catch (error) {
    console.log(error);
  }
}

makeRequest("http://example.com/");

// async 키워드로 선언되어 네트워크 요청의 결과를 기다리기 위해 await 키워드를 사용할 수 있다.
// 호출자는 함수 실행 중 발생할 수 있는 에러를 처리하기 위해 try-catch 키워드를 사용할 수 있다.
```

## 9.2 배경

- 자바스크립트에서 콜백 함수는 다른 함수에 인수로서 전달되어, 비동기 작업이 완료된 후 실행된다.
- 콜백을 사용할 때 주요 단점 중 하나는 콜백 지옥으로 불리는 상황을 초래할 수 있다는 점이다.
- 콜백 지옥은 중첩된 콜백 구조로 인해 코드의 가독성과 유지보수성이 크게 저하되는 상황을 뜻한다.

## 9.3 프로미스 패턴

- 프로미스는 자바스크립트에서 비동기 작업을 처리하는 최신 방법이다.
- 프로미스는 비동기 작업의 결과를 나타내는 객체로 대기, 완료, 거부의 세가지 상태를 가질 수 있다.

```jsx
function makeRequest(url) {
  return new Promise((resolve, reject) => {
    fetch(url)
      .then((response) => response.json())
      .then((data) => resolve(data))
      .catch((error) => reject(error));
  });
}

makeRequest("http://example.com/")
  .then((data) => console.log(data))
  .catch((error) => console.error(error));
```

- makeRequest 함수는 네트워크 요청의 결과를 나타내는 Promise 객체를 반환한다.
- 요청이 성공하면 Promise는 응답을 완료하여 데이터를 반환하고, 실패하면 에러와 함께 거부된다.
- 호출자는 반환된 Promise 객체의 .then .catch 메서드를 통해 요청의 결과를 처리할 수 있다.
- 프로미스를 사용할 때의 주요 장점 중 하나는 콜백보다 체계적이고 가독성이 높은 방법으로 비동기 작업을 처리할 수 있다는 것이다.

### 9.3.1 프로미스 체이닝

- 프로미스 체이닝 패턴을 사용하면 여러 개의 프로미스를 함께 연결하여 보다 복잡한 비동기 로직을 만들 수 있다.

```jsx
function makeRequest(url) {
  return new Promise((resolve, reject) => {
    fetch(url)
      .then((response) => response.json())
      .then((data) => resolve(data))
      .catch((error) => reject(error));
  });
}

function processData(data) {
  return processedData;
}

makeRequest("http://example.com/")
  .then((data) => processData(data))
  .then((processedData) => console.log(processedData))
  .catch((error) => console.error(error));
```

### 9.3.2 프로미스 에러 처리

- 프로미스 에러 처리 패턴은 catch 메서드를 사용하여 프로미스 체인의 실행 중 발생할 수 있는 에러를 처리한다.

### 9.3.3 프로미스 병렬 처리

- 프로미스 병렬 처리 패턴은 Promise.all 메서드를 사용하여 여러 프로미스를 동시에 실행 할 수 있게 한다.

```jsx
Promise.all([
	makeRequest('http://example.com/1')
	makeRequest('http://example.com/2')
]).then(([data1, data2]) => {
	console.log(data1, data2)
})
```

### 9.3.4 프로미스 순차 실행

- 프로미스 순차 실행 패턴은 Promise.resolve 메서드를 사용하여 프로미스를 순차적으로 실행할 수 있도록 해준다.

```jsx
Promise.resolve()
  .then(() => makeRequest1())
  .then(() => makeRequest2())
  .then(() => makeRequest3())
  .then(() => {
    // 모든 요청 완료
  });
```

### 9.3.5 프로미스 메모이제이션

- 프로미스 메모이제이션 패턴은 캐시를 사용하여 프로미스 함수 호출의 결과값을 저장하며 이를 통해 중복된 요청을 방지할 수 있다.

```jsx
const cache = new Map();

function memoizedMakeRequest(url) {
  if (cache.has(url)) return cache.get(url);

  return new Promise((resolve, reject) => {
    fetch(url)
      .then((response) => response.json())
      .then((data) => {
        cache.set(url, data);
        resolve(data);
      })
      .catch((error) => reject(error));
  });
}

const button = document.querySelector("button");
button.addEventListener("click", () => {
  memoizedMakeRequest("http://example.com/")
    .then((data) => console.log(data))
    .catch((error) => console.error(error));
});
```

### 9.3.9 프로미스 경쟁

- 프로미스 경쟁 패턴은 여러 프로미스를 동시에 실행하고 가장 먼저 완료되는 프로미스의 결과를 반환한다.

```jsx
promise.race([
	makeRequest1(URL1)
	makeRequest2(URL2)
]).then(data => {
	console.log(data)
})
```

## 9.4 async/await 패턴

- async/await는 비동기 코드를 마치 동기 코드 처럼 작성할 수 있게 해주는 자바스크립트의 기능
- 프로미스 기반으로 구축되었으며 비동기 코드 작업을 보다 쉽고 간결하게 만들어 준다.
